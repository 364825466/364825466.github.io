[{"title":"多线程基础","url":"/2021/06/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","content":"多线程\n\n为什么要多线程：为了提高CPU的利用率\n进程和线程区别\n起源不同\n先有进程，后有线程，处理器的速度往往要比外设要快，所以为了提高CPU的利用率，所以创造了线程。\n\n\n概念不同\n进程：进程的英文是Process，指的是程序的一次执行。在用户下达运行程序的命令后，就会产生进程，是程序运行起来的实例。是系统资源分配的基本单位。\n线程：是CPU的基本调度单位\n\n\n内存共享方式不同\n进程：不同的进程之间都会被操作系统分配到一定内存，但是不同进程之间的内存通常是不共享的，比如我们的浏览器无法访问我们的QQ音乐，它们想通信除非使用高级技巧进程间通信IPC\n线程：线程共享起来就很容易，因为他们都服务于同一个进程，通信起来很容易，可以直接访问一定量的共享内存\n\n\n拥有的资源不同\n线程是进程的一部分，所以拥有的资源肯定是小于进程的，但是他也有一些独有的内容。\n线程共享的内容：比如进程代码片段等\n线程独有的内容：线程的堆栈等\n\n\n数量不同\n一个进程至少拥有一个线程\n\n\n开销不同\n线程的创建，终止时间比进程短\n同一进程的线程切换时间比进程切换短\n同一进程的各个线程间共享内存和文件资源，可以不通过内核进行通信\n\n\n相似点：生命周期\n\n并发和并行\n\n并行\n\n真正的同时运行——在同一时刻，有多个任务同时执行\n例如：在多核处理器上，有两个线程同时执行一段代码。可见，单核处理器是无法实现并行的，因为单核处理器无法在同一时刻执行多个任务。\n\n\n并发\n\n并发的2种概念\n\n形容多个任务的执行状态\n两个或多个任务可以在重叠时间段内启动，运行和完成\n并行（两个线程同时执行）一定是并发\n不一定意味着并发一定要求是并行\n\n对”并发性“的简称\n不同的部分可以无序或同时执行，且不影响最终的执行结果\n\n\n\n\n\n\n\n高并发有哪些指标\nQPS（Queries Per Second）每秒查询数\n带宽\nPV（Page View）：24h的页面访问量\nUV（Unique Visitor）：在PV基础上的去重，也就是在此基础上的用户数量\n并发连结数\n服务器平均请求等待时间\n\n同步与异步，阻塞与非阻塞同步与异步被调用者是否主动告诉调用者结果\n\n同步：同步异步这里指的是调用者（也就是服务器）的行为，而不是请求方的行为。在没有得到结果之前，服务端就不会返回任何结果。\n异步：调用在发出之后，服务端会立刻返回，告诉调用方“我收到消息了，我会处理的”\n\n比如烧水，水壶没有提醒功能 需要一直看着水开没开就是同步，水开了自动提醒你的是异步\n阻塞和非阻塞\n站在线程状态的角度    \n是线程6种状态的其中三种，可以理解为线程不执行了，需要等待一段时间或者等待别人唤醒它。\n\n\n站在线程发出请求（通常是HTTP请求）的角度\n站在发出者角度，比如烧水，我们等待水烧开就是阻塞，烧水的时候我们去干别的就是非阻塞。\n\n\n\n组合概念用烧水的概念，同步异步形容水壶（服务端），阻塞非阻塞形容烧水的人（请求方）\n\n同步阻塞：我们开始烧水，用的老水壶，不会提醒开没开那种，然后一直坐着，一直盯着里面的水，等着水烧开\n同步非阻塞：我们还是用原来的水壶，水壶不会提醒我们水开没开，因为我们是非阻塞的，我们就去干别的事情，每隔几分钟看看水开没开\n异步阻塞：我们烧水，水壶有水开了提醒功能，我们坐着等，听到有提醒水开了再把水壶拿下来\n异步非阻塞：我们烧水，水壶有水开了提醒功能，我们去干别的，听到有声音了再把水壶拿下来\n\n多线程概念建立——常见面试题\n进程和线程的相同与不同？\n\n并行和并发的异同？\n\n高并发是不是意味着多线程？有什么反例？\n\n高并发是指我们服务器受到了很多的请求，有很大的压力。\n多线程是高并发问题的一个解决方案\n反例：redis 是单线程的，同样可以支持高并发的场景\n\n\n多线程可以提高程序执行效率，你知不知道有那些弊端？\n\n性能问题：上下文切换啊，保存CPU catche等可能带来性能损耗\n有些任务 比如异构化任务等，多线程不如单线程合适\n线程安全问题\n\n\n什么是同步 异步 阻塞 非阻塞？\n\n水壶烧水解释\n\n\n在单核CPU上运行多线程程序有意义吗？\n\n有意义，单核是不能并行的，因为只有一个处理器，但是我们不知道这个程序未来会在单核还是多核下运行，所以我们要以多核为准\n\n\n\n","categories":[],"tags":["多线程"]},{"title":"PDMan数据库建模工具","url":"/2021/04/22/PDMan%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7/","content":"PDMan数据库建模工具一开始做数据库设计的时候，不会直接去数据库做设计的，往往会使用一些数据库建模工具\nPDMan是一个开源的建模工具，官网 http://www.pdman.cn/#/ ，支持全平台的下载。\n\n\n基本使用创建新的项目\n\n选择完路径后确认，页面是这样\n\n点击设置的话可以更改一些新建表的默认字段，比如createDate之类的\n\n我们点击左侧的新增模块，名字为test\n\n这就相当于我们新建了一个数据库，点击数据表 -&gt; 新增数据表，名字为user_tab\n\n双击表，可以看到详细信息\n\n逻辑名就是对应到mysql中的表名。\n点击字段信息，我们可以编辑新增字段，这里我们新建一个主键\n\n点击代码信息，可以看到建表SQL、Java实体类等，非常实用\n\n我们双击左侧的关系图，把user_tab拖过去，就可以看到他的关系图\n\n同步到数据库我们点击开始 -&gt; 数据库连结 -&gt; 加号 -&gt; 填上我们数据库的信息，就可以连结到数据库了\n\n然后我们要把表的信息生成到数据库中去\n模型版本可以理解为类似git的功能，用来管理版本信息 提交记录等\n点击模型版本 -&gt;  初始化基线 -&gt; 输入版本信息和描述 ，点击确定\n\n初始化后，可以在自己的数据库中看到PDMAN_DB_VERSION表，这个我们不要删除\n我们可以看到最新的一个没有同步到数据库，我们把他同步一下\n\n然后我们点击同步到数据库，因为版本原因，这个功能没有，正常是有一个同步按钮的,我们只能收到粘贴脚本\n\n注意：我们同步配置 一定要选择字段增量，要是选择了重建数据表就是把之前的表删了重建一个\n\n","categories":[],"tags":["MySQL"]},{"title":"Spring事务传播性","url":"/2021/02/19/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%80%A7/","content":"聊聊你对Spring事务传播性的理解\n\n定义Spring事务传播性是为了解决事务嵌套问题的，定义了一系列的传播行为，规定多个含有事务的方法嵌套调用时，应该采用哪种策略来处理。\n事务传播行为1. PROPAGATION_REQUIREDSpring默认的传播行为，如果外层方法已经开启了事务，那么当前方法就加入外层事务；如果外部方法没有事务，那么当前方法就开启一个事务。\n这个传播行为可以保证多个嵌套的事务方法在同一个事务内执行，也就是可以保证多个事务方法同时提交，同时回滚。这个机制可以满足大多数业务场景。\n\n\n\n\nServiceA的methodA方法调用了 ServiceB的methodB方法，其中ServiceA中的methodA通过注解@Transactional加了一个事务切面，事务的传播性设置为了REQUIRED\n当调用者调用方法methodA时，如果调用者没有开启事务，那么由于methodA的事务传播性为REQUIRED，所以会开启一个事务，执行methodB方法\n由于methodB事务传播性时REQUIRED，并且它的调用者methodA已经开启了事务，所以methodB会合并到methodA开启的事务中执行，也就是method A和B 各自的数据库操作是在同一个事务内进行的\n当A和B 都执行完毕后，会提交事务\n\n\n\n如果在methodB发生异常，那么methodA和B中的插入操作都会被回滚，因为是在同一个事务内执行的，而事务是可以保证原子性操作的\n\n\n如果methodB抛出异常后，methodA使用try-catch语句catch住了异常，并没有向外抛出，那么methodA也会回滚，因为事务传播行为REQUIRED的语义就是嵌套调用的多个方法在一个事务内执行，而事务本身是有原子性的，所以只要有一个事务抛出异常且回滚了，那么在同一个事务内的其他事务方法的执行也会回滚。\n\n\n\n2. PROPAGATION_REQUIRES_NEW每次都新开启一个事务，如果外层调用方已经开启了事务，那就先把外层事务挂起，然后执行当前新事务，执行完毕后再恢复上层事务的执行\n\n\n\n如果内层事务方法抛出了异常，并且外层事务方法catch住了异常，并没有向外抛出，则外层事务不会回滚。\n\n如果内层事务抛出异常，并且外层事务方法没有catch掉异常，则外层事务也会回滚。\n\n\n\n3. PROPAGATION_SUPPORTED如果外层调用方开启了事务，那当前方法就加入到外层事务；如果外层不存在事务，那么当前方法也不会创建新事务，直接使用非事务方法执行。\n\nmethodB为SUPPORTED，并且它的调用方methodA没有开启事务，所以methodB会以非事务方式运行。\n\n\n\n\nmethodA为REQUIRED，，A会开启事务，由于methodB为SUPPORTED，并且其调用方A开启了事务，所以B会加入到A的事务内运行\n\n\n\n4. PROPAGATION_NOT_SUPPORTED不支持事务，如果外层调用者开启了事务，就挂起外层事务，然后以非事务方式执行当前方法逻辑，等执行完毕后再恢复外层事务的执行。\n\n5. PROPAGATION_NEVER不支持事务，如果外层调用者开启了事务，就执行当前方法并抛出异常。\n\n6. PROPAGATION_NEVER配置了这个传播性的方法只能在已经存在事务的方法红被调用，如果在不存在事务的方法中被调用，就会抛出异常。\n\n7. PROPAGATION_NESTED嵌套调用，当外层调用方存在事务时，当前方法会合并到外层事务，如果外层不存在事务，就当前开启事务，这和REQUIRED一致，不同点为 NESTED可以保存状态保存点，当事务回滚时可以回滚到某一个保存点上，从而避免所有嵌套事务都回滚。\n\nmethodA执行时，如果调用方没有开启事务则会开启事务，然后执行插入操作\n\n执行1.2时由于methodB传播性为NESTED，所以会新建一个savepoint，用于标记代码1.1执行的插入操作\n\nmethodB是使用A开启的事务的，B执行抛出异常时，B的插入操作会被回滚掉\n\n而A中的代码1.1操作不会回滚掉，因为建立的保存点，B的回滚只会回滚到这个保存点之前，并且B回滚后，代码1.1和1.3的执行都会被提交到数据库\n\n\n\n工作我们常用到的事务传播行为有两种\n\nREQUIRED：可以保证多个事务方法在哦同一个事务内执行，而事务是具有原子性的，所以这个传播性可以保证多个事务方法执行的原子性。比如当应用层需要编排不用业务域的服务时限一个功能时，就需要每个业务域的方法都配置为REQUIRED，从而保证不同业务域的方法同事提交变动或者同事回滚变动\n\nREQUIRED_NEW：可以保证内层方法开启独立于外层方法的事务，这样当内层方法抛出异常回滚自己的事务时，不会影响外层事务方法的执行，这种传播性更适用于内层方法的执行独立于外层方法执行的场景。比如：执行业务逻辑的服务方法调用写日志表服务的方法时，如果打日志抛异常了，就不应该让业务逻辑服务方法回滚。\n\n\n","categories":[],"tags":["Spring"]},{"title":"Nginx初识","url":"/2020/10/10/Nginx%E5%88%9D%E8%AF%86/","content":"nginx简介\n\n1. 什么是nginxnginx是一个高性能的HTTP和反向代理服务器，特点是占用内存少，并发能力强。\nnginx专为性能优化而开发，性能是极其重要的指标，实际上非常注重效率，能经受高负载的考验，有报告表明能支持50000个并发连接数。\n\n2. 反向代理Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。\n\n正向代理如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访 问 Internet，则需要通过代理服务器来访问，客户端（浏览器）一般要配置正向代理服务器，这种代理服务就称为正向代理。\n\n\n反向代理：其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只 需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返 回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器 地址，隐藏了真实服务器 IP 地址。\n\n\n\n3. 负载均衡​    客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服 务器处理完毕后，再将结果返回给客户端。 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成 本也低。\n​    但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂 度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情 况呢？ \n​    我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能 满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量 是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能 够满足需求的。那么怎么办呢？\n​    上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题 的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。\n\n4. 动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速 度。降低原来单个服务器的压力。\n\n","categories":[],"tags":["nginx"]},{"title":"如何使用Excel处理复杂数据","url":"/2020/09/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Excel%E5%A4%84%E7%90%86%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE/","content":"\n\n1. 问题抛出最近新开一个项目，房间、业主等数据都要从别的系统导入，字段完全对不上，同步的接口又没有，十几万条数据给我搞得头皮发麻。\n我的处理方法是：\n\n把他们的表导出为SQL  \n对比两个表的字段，不同的就先在我们表里加上 \n用notepad++ 修改我们的SQL，insert的字段对应上，再全部替换 \n然后跑SQL \n最后把新加的那些没用的字段删除\n\n虽然能实现，但是太麻烦了，新加了这么多字段  SQL跑的又慢\n2. 解决询问了一圈后，四少给了我一个更实用的解决方案：\n\n首先在navicat ，查出你想要的数据，导出为excel表格\n\n设计到主键UUID的话，在项目里随便找个导出方法，循环15W个UUID并导出\n\n导出的UUID放到EXCEL里，然后在最后一列写SQL\n=&quot;INSERT ignore INTO `tbo_owner_info_new`  (ownerinfo_id,owner_name,project_name) values (&#x27;&quot;&amp;R2&amp;&quot;&#x27;,&#x27;&quot;&amp;L2&amp;&quot;&#x27;,&#x27;&quot;&amp;C2&amp;&quot;&#x27;);&quot;\n\nSQL按照自己的需要写，values里的值 就是单元格的坐标，注意符号都不要删\n\n然后鼠标放单元格右下角，变成黑十字往下拉，要的SQL就全出来了\n\n数据太多，就先选中最后一行，Ctrl+Shift+↑  ，选中这一列的所有，再Ctrl+D就可以了\n\n最后选中这列，复制，跑SQL就可以了！\n\n\n","categories":[],"tags":["excel"]},{"title":"Hibernate的延迟加载与动态代理","url":"/2020/08/19/Hibernate%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","content":"问题抛出今天查询楼栋接口突然报错，经过排查后发现是楼栋关联的buildingDetailUser，在user表中查不到，所以在getUser的时候就为空了，再getUserId就会报错，正常是不会出现这种情况的，因为系统中的删除都是逻辑删除，不会出现userId查不到的情况，估计是哪个小子手抖在数据库不小心删了条数据…(别让我抓到你)，于是老大让我在getUserId之前加一层判断，判断getUser为空就不往下走了。\n修改后看如下业务代码\n\n\nBuildingDetail buildingDetail = buildingService.findByBuildingId(buildingId);Set&lt;BuildingDetailUser&gt; buildingUser = buildingDetail.getBuildingUser();List&lt;Map&lt;String, Object&gt;&gt; userData = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();for(BuildingDetailUser detailUser:buildingUser)&#123;\tMap&lt;String,Object&gt; objUserTemp = new HashMap&lt;String,Object&gt;();\tif(detailUser.getUser() != null)&#123;\t\tobjUserTemp.put(&quot;dictId&quot;, detailUser.getRole().getRoleid());\t\tobjUserTemp.put(&quot;userId&quot;, detailUser.getUser().getUserid());\t\tobjUserTemp.put(&quot;userName&quot;, detailUser.getUser().getUserName());\t\tuserData.add(objUserTemp); \t&#125;&#125;map.put(&quot;userData&quot;, userData);\n\n根据buildingId，得到楼栋信息，再getBuildingUser——&gt;getUser ——&gt; getUserId\nBuildingDetail 实体类中封装了 BuildingDetailUser\nprivate Set&lt;BuildingDetailUser&gt; buildingUser = new HashSet&lt;BuildingDetailUser&gt;();@OneToMany(cascade = &#123;CascadeType.PERSIST, CascadeType.MERGE &#125;, fetch = FetchType.LAZY, mappedBy = &quot;buildingDetail&quot;)public Set&lt;BuildingDetailUser&gt; getBuildingUser() &#123;\treturn buildingUser;&#125;public void setBuildingUser(Set&lt;BuildingDetailUser&gt; buildingUser) &#123;\tthis.buildingUser = buildingUser;&#125;\n\nBuildingDetailUser 实体中，又封装了User\nprivate User user; // 关联人员@ManyToOne(cascade=&#123;CascadeType.PERSIST, CascadeType.REFRESH&#125;, fetch=FetchType.LAZY)@JoinColumn(name=&quot;user_id&quot;)public User getUser() &#123;\treturn user;&#125;public void setUser(User user) &#123;\tthis.user = user;&#125;\n\n\n\n这样就可以一直get到userId，这么看没什么毛病\n但是在debug的过程中，发现了奇怪的事情，debug过程中，对buildingUser遍历，detailUser.getUser() 只有一个userId不为空，而且得到的userId每次都不一样，和数据库也对不上，并且我把数据库中对应的user删除，detailUser.getUser() 也不为空\n这就奇了怪了，一开始我还以为是编译器的锅（eclipse对不起 -.-! ），后来重启，刷新之后还是这种情况。这样我就没法做判断了啊，getUser无论如何都不为空，再getUserId就会报错。\n原因：我去询问大佬（兄弟们把樊华NB打在公屏上！！），发现了这段代码\nBuildingDetailUser :\n@ManyToOne(cascade=&#123;CascadeType.PERSIST, CascadeType.REFRESH&#125;, fetch=FetchType.LAZY)@JoinColumn(name=&quot;user_id&quot;)public User getUser() &#123;\treturn user;&#125;public void setUser(User user) &#123;\tthis.user = user;&#125;\n\nUser:\npublic User() &#123;\tsuper();\tthis.userid = UUID.getUUID();&#125;\n\n原来是这里配置了懒加载，得到的是hibernate动态代理对象\nhibernate首先返回的是目标查询对象的代理对象，就是先看数据库有没有这条数据，有的话返回一个动态代理对象，其实就是User的一个子类。当需要使用目标对象的属性时候，如：user.getUserId();  hibernate再用SQL语句在数据中进行查询；\n延迟加载其实也是一样，要查询对象时候不是马上到数据库中进行查询而是先在内存中生成一个代理对象，当要使用数据时候才到数据库中进行查询；\n解决那么修改就简单了，因为我是要过滤掉user为空的buildingDetailUser，那就不用hibernate这样的方式，直接写SQL，用inner join关联User查询就好了\nList&lt;Map&lt;Object,Object&gt;&gt; buildingUser = buildingUserDao.findBuildingDetailUserByMap(buildingUserMap);// 这个方法的sql自行脑部，很简单inner join关联，查什么就拿什么就好了List&lt;Map&lt;String, Object&gt;&gt; userData = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();for (Map&lt;Object,Object&gt; detailUser : buildingUser) &#123;\tMap&lt;String, Object&gt; objUserTemp = new HashMap&lt;String, Object&gt;();\tobjUserTemp.put(&quot;dictId&quot;, detailUser.get(&quot;roleId&quot;));\tobjUserTemp.put(&quot;userId&quot;, detailUser.get(&quot;userId&quot;));\tobjUserTemp.put(&quot;userName&quot;, detailUser.get(&quot;userName&quot;));\tuserData.add(objUserTemp);\t&#125;map.put(&quot;userData&quot;, userData);\n\n\n\nHibernate的延迟加载与动态代理所以，开头说到的奇怪现象的原因是什么呢？其实在hibernate设置延迟加载后，hibernate返回给我们的对象（要延迟加载的对象）是一个代理对象，并不是真实的对象，该对象没有真实对象的数据，只有真正需要用到对象数据（调用getter等方法时）时，才会触发hibernate去数据库查对应数据，而且查回来的数据不会存储在代理对象中，所以这些数据是无法在调试窗口查看到的。\n如果在调试是要查看该数据，我们可以查看代理对象中的hadler属性中的target变量，该对象变量才是真实的对象\n也就是说，我们user变量仅仅是一个代理类，target才是真正数据库中获取的数据。当我们在调用getter方法式，hibernate会利用动态代理的方法，直接调用target中的getter方法发挥对应的值。这样也解释了为什么hibernate可以延迟加载：通过代理类进行加载时间的控制，在外界正真调用getter等方法操作数据时才会对相应的方法进行拦截，然后读取数据库。\n","categories":[],"tags":["bug"]},{"title":"SpringBoot/Cloud 配置文件on读取为true","url":"/2020/08/17/SpringBoot-Cloud-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6on%E8%AF%BB%E5%8F%96%E4%B8%BAtrue/","content":"问题抛出：最近在写 SpringBoot 项目时需要配置开关,按照以往写项目的习惯,就在配置文件命名了key 之后写了 on.项目启动之后,神奇的事情出现了,项目读取到的值居然变成了 true ！\n解决：通过万能的百度… ，得知在on上加上单引号,变成’on’,代码读取出来的终于读到了正确的”on”!\n测试问题是解决了,但是对于出现这样的原因还是不明白,做了大胆的猜测:SpingBoot底层在读取配置文件时如果读取到了非字符串 on 则会转换成true,那么相应的,如果配置了非字符串 off,应该会读取成false , on 和off 对于SpingBoot是两个特殊的单词,会转义.本着这个猜测,做了如下测试:\n配置项:ceshi:  ceshi1: on  ceshi2: off  ceshi3: &#x27;on&#x27;  ceshi4: &#x27;off&#x27;  ceshi5: abc\n\n测试代码以及debug结果测试接口：@RestControllerpublic class ceshi &#123;    @Value(&quot;$&#123;ceshi.ceshi1&#125;&quot;)    public String ceshi1;    @Value(&quot;$&#123;ceshi.ceshi2&#125;&quot;)    public String ceshi2;    @Value(&quot;$&#123;ceshi.ceshi3&#125;&quot;)    public String ceshi3;    @Value(&quot;$&#123;ceshi.ceshi4&#125;&quot;)    public String ceshi4;    @Value(&quot;$&#123;ceshi.ceshi5&#125;&quot;)    public String ceshi5;    @ApiOperation(value = &quot;测试&quot;)    @GetMapping(&quot;/test&quot;)    public void test() &#123;        System.out.println(ceshi1);        System.out.println(ceshi2);        System.out.println(ceshi3);        System.out.println(ceshi4);        System.out.println(ceshi5);    &#125;&#125;\n\n结果\n由上面的配置项代码可以看出: on 和 off 确实被读取成了 true和false, 带引号的’on’和’off’才会读取成 on 和off ,而普通的字符不带上单引号仍然读出是相应的字符串.\n总结on和off带有开关的常识，SpingBoot/Cloud底层将这两个单词进行了转义,在我们实在需要使用这两个单词作为配置项但是又不想读取成true或者false的时候,最好带上单引号.\n","categories":[],"tags":["bug"]},{"title":"course-2.SpringBoot项目技术整合","url":"/2020/08/07/course-2-SpringBoot%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%95%B4%E5%90%88/","content":"\n\n1. System模块集成持久层框架MyBatis新建数据库新建数据库course\n\n因为用的root用户，所以新建完之后本地的数据库都能看见，为了解决这个问题，只能看到course，新建用户\n\n然后点击刚才创建的用户，点击权限，添加权限，点击course，右边全打上对号\n\n然后确定后，点SQL预览，这个sql可以以后拿去生产环境\nGRANT Alter, Alter Routine, Create, Create Routine, Create Temporary Tables, Create View, Delete, Drop, Event, Execute, Grant Option, Index, Insert, Lock Tables, References, Select, Show View, Trigger, Update ON `course`.* TO `course`@`localhost`;\n\n\n\n然后新建连结course ，用户名改为刚才创建的\n\n现在就只能看到一个course库了\n新建表\nCREATE TABLE `course`.`Untitled`  (  `id` varchar(255) NOT NULL,  `name` varchar(255) NULL,  PRIMARY KEY (`id`));\n\n修改配置然后添加依赖\n&lt;!-- 集成mybatis --&gt;\t\t\t&lt;dependency&gt;\t\t\t\t&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\t\t\t\t&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\t\t\t\t&lt;version&gt;1.3.2&lt;/version&gt;\t\t\t&lt;/dependency&gt;\t\t\t&lt;dependency&gt;\t\t\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\t\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\t\t\t\t&lt;version&gt;5.1.37&lt;/version&gt;\t\t\t&lt;/dependency&gt;\n\n要先向父pom下的dependencyManagement下加\n\n现在父模块已经不是springboot项目了，所以父pom下的这个也可以全删了\n\n然后向system的pom加，把version删掉\n\n在system的application.properties里接入数据库连接配置\n# 增加数据库连接spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/course?characterEncoding=UTF8&amp;autoReconnect=truespring.datasource.username=coursespring.datasource.password=123456\n\n添加测试接口测试：\n在system下船舰domain，新建Test实体类\n\nsystem的启动类加入注解@MapperScan(&quot;com.course.system.mapper&quot;)，让springboot能扫描到mapper\napplication加入配置\nmybatis.mapper-locations=classpath:/mapper/*.xml\n\n然后加入controller，service，mapper层，写个小接口\n\nTestMapper.xml:\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.course.system.mapper.TestMapper&quot;&gt;&lt;select id=&quot;list&quot; resultType=&quot;com.course.system.domain.Test&quot;&gt;    select * from test&lt;/select&gt;    &lt;/mapper&gt;\nTestMapper:\npackage com.course.system.mapper;import com.course.system.domain.Test;import java.util.List;public interface TestMapper &#123;    public List&lt;Test&gt; list();&#125;\nTestService:\npackage com.course.system.service;import com.course.system.domain.Test;import com.course.system.mapper.TestMapper;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class TestService &#123;    @Resource    private TestMapper testMapper;    public List&lt;Test&gt; list()&#123;        return testMapper.list();    &#125;&#125;\nTestController:\npackage com.course.system.controller;import com.course.system.domain.Test;import com.course.system.service.TestService;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.List;@RestControllerpublic class TestController &#123;    @Resource    private TestService testService;    @RequestMapping(&quot;/test&quot;)    public List&lt;Test&gt; test()&#123;        return testService.list();    &#125;&#125;\n\n启动项目，接口走通\n现在目录结构如下：\n\n2. 集成热部署system的pom下加入依赖\n&lt;!-- 热部署DevTools --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;/dependency&gt;\n\n然后改设置\n\n然后shift shift 搜索registry  这个打勾\n\n3. 加入打印日志system的application加入\nlogging.level.com.course.system.mapper=trace\n\n我们要给哪一个包用什么日志级别，用trace可以打印出sql还有执行的结果\n非常方便调试！\n","categories":[],"tags":["SpringCloud","course"]},{"title":"SpringCloud原理图","url":"/2020/08/06/SpringCloud%E5%8E%9F%E7%90%86%E5%9B%BE/","content":"\n\n针对这个架构图我分层介绍一下：\n1、是web服务器的选型，这个我选择的是nginx+keepalived，haproxy也是一个选择，但是haproxy在反向代理处理跨域访问的时候问题很多。所以我们nginx有些地方做了keep-alive模式处理，减少了三次握手的次数，提高了连接效率。keepalived做nginx的负载，虚拟一个vip对外，两个nginx做高可用，nginx本身反向代理zuul集群。\n2、api gateway，这里的zuul很多人诟病，说是速度慢推荐直接用nginx，这里我还是推荐使用zuul的，毕竟zuul含有拦截器和反向代理，在权限管理、单点登录、用户认证时候还是很有用的，而且zuul自带ribbon负载均衡，如果你直接用nginx，还需要单独做一个feign或者ribbon层，用来做业务集群的负载层，毕竟直接把接口暴露给web服务器太危险了。这里zuul带有ribbon负载均衡和hystrix断路器，直接反向代理serviceId就可以代理整个集群了。\n3、业务集群，这一层我有些项目是分两层的，就是上面加了一个负载层，下面是从service开始的，底层只是单纯的接口，controller是单独一层由feign实现，然后内部不同业务服务接口互调，直接调用controller层，只能说效果一般，多了一次tcp连接。所以我推荐合并起来，因为做过spring cloud项目的都知道，feign是含有ribbon的，而zuul也含有ribbon，这样的话zuul调用服务集群，和服务集群间接口的互调都是高可用的，保证了通讯的稳定性。Hystrix还是要有的，没有断路器很难实现服务降级，会出现大量请求发送到不可用的节点。当然service是可以改造的，如果改造成rpc方式，那服务之间互调又是另外一种情况了，那就要做成负载池和接口服务池的形式了，负载池调用接口池，接口池互相rpc调用，feign client只是通过实现接口达到了仿rpc的形式，不过速度表现还是不错的。\n4、redis缓存池，这个用来做session共享，分布式系统session共享是一个大问题。同时呢，redis做二级缓存对降低整个服务的响应时间，并且减少数据库的访问次数是很有帮助的。当然redis cluster还是redis sentinel自己选择。\n5、eurake注册中心这个高可用集群，这里有很多细节，比如多久刷新列表一次，多久监测心跳什么的，都很重要。\n6、spring admin，这个是很推荐的，这个功能很强大，可以集成turbine断路器监控器，而且可以定义所有类的log等级，不用单独去配置，还可以查看本地log日志文件，监控不同服务的机器参数及性能，非常强大。它加上elk动态日志收集系统，对于项目运维非常方便。\n7、zipkin，这个有两种方式，直接用它自己的功能界面查看方式，或者用stream流的方式，由elk动态日志系统收集。但是我必须要说，这个对系统的性能损害非常大，因为链路追踪的时候会造成响应等待，而且等待时间非常长接近1秒，这在生产环境是不能忍受的，所以生产环境最好关掉，有问题调试的时候再打开。\n8、消息队列，这个必须的，分布式系统不可能所有场景都满足强一致性，这里只能由消息队列来作为缓冲，这里我用的是Kafka。\n9、分布式事物，我认为这是分布式最困难的，因为不同的业务集群都对应自己的数据库，互相数据库不是互通的，互相服务调用只能是相互接口，有些甚至是异地的，这样造成的结果就是网络延迟造成的请求等待，网络抖动造成的数据丢失，这些都是很可怕的问题，所以必须要处理分布式事物。我推荐的是利用消息队列，采取二阶段提交协议配合事物补偿机制，具体的实现需要结合业务，这里篇幅有限就不展开说了。\n10、config配置中心，这是很有必要的，因为服务太多配置文件太多，没有这个很难运维。这个一般利用消息队列建立一个spring cloud bus，由git存储配置文件，利用bus总线动态更新配置文件信息。\n11、实时分布式日志系统，logstash收集本地的log文件流，传输给elasticsearch，logstash有两种方式，1、是每一台机器启动一个logstash服务，读取本地的日志文件，生成流传给elasticsearch。2、logback引入logstash包，然后直接生产json流传给一个中心的logstash服务器，它再传给elasticsearch。elasticsearch再将流传给kibana，动态查看日志，甚至zipkin的流也可以直接传给elasticsearch。这个配合spring admin，一个查看动态日志，一个查看本地日志，同时还能远程管理不同类的日志级别，对集成和运维非常有利。\n最后要说说，spring cloud的很多东西都比较精确，比如断路器触发时间、事物补偿时间、http响应时间等，这些都需要好好的设计，而且可以优化的点非常多。比如：http通讯可以使用okhttp，jvm优化，nio模式，数据连接池等等，都可以很大的提高性能。\n还有一个docker问题，很多人说不用docker就不算微服务。其实我个人意见，spring cloud本身就是微服务的，只需要jdk环境即可。编写dockerfile也无非是集成jdk、添加jar包、执行jar而已，或者用docker compose，将多个不同服务的image组合run成容器而已。但是带来的问题很多，比如通讯问题、服务器性能损耗问题、容器进程崩溃问题，当然如果你有一套成熟的基于k8s的容器管理平台，这个是没问题的，如果没有可能就要斟酌了。而spring cloud本身就是微服务分布式的架构，所以个人还是推荐直接机器部署的，当然好的DevOps工具将会方便很多。\n服务注册发现组件Eureka工作原理\n服务网关组件Zuul工作原理\n跨域时序图\nEureka与Ribbon整合工作原理\n解决分布式一致性\n级联故障流程\n断路器组件Hystrix工作原理\n分布式追踪Sleuth工作原理\nSpringBoot自动配置工作原理\n\n转自：https://www.jianshu.com/p/5e0583583ee6\n\n","categories":[],"tags":["SpringCloud"]},{"title":"course-1.SpringCloud项目搭建","url":"/2020/08/06/course-1-SpringCloud%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","content":"1.SpringCloud项目搭建\n\n1. 去spring官网  新建springBoot项目使用springboot的官方工具initializr 来搭建springboot项目\n\n依赖就先选择一个Eureka Server\n然后解压缩，用idea打开\n2. 使用git管理项目在idea的Terminal，输入：\ngit init\n\n然后直接上传下代码，首次可能要输入账号密码\n3. 将单个springBoot项目改造成为多个springBoot子项目项目上 -&gt; 右键 -&gt; new -&gt; Module -&gt; 选择maven  ， 新建eureka子项目，点击完成\n\n4. 将父模块pom的eureka依赖搬到子项目打开父模块pom，找到 spring-cloud-starter-netflix-eureka-server 依赖，直接剪切到eurkea子项目的pom下\n子项目pom：\n\n5. 把启动文件搬到eureka模块在eureka的java目录下新建包： com.course，然后把父模块的启动类 CourseApplication拷到此目录下，名字改为EurekaApplication，然后就可以启动了。然后把父模块的src全部删除，现在的目录如下：\n\n6. 解决Eureka启动失败问题以及日志输出优化\n首先解决eureka启动失败的问题\n在eureka的resources下新建application.properties\nspring.application.name=eurekaserver.port=8761eureka.client.fetch-registry=falseeureka.client.register-with-eureka=false\n\n\n8761是eureka的默认端口\neureka.client.fetch-registry：获取注册信息，默认为true，因为我们本身就是注册中心了，所以改成false。\neureka.client.register-with-eureka：注册到一个eureka，默认为true，我们本身就是注册中心，所以改成false。\n\n然后在启动类中加入@EnableEurekaServer注解，就可以正常启动了\n\n\n\n\n然后美化我们的日志\n首先修改EurekaApplication启动类\npackage com.course;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;import org.springframework.core.env.Environment;@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123;    // springboot默认继承slf4j框架，它定义了一些日志接口，规范日志输入，\t// 真正的实现是logback或log4j,我们代码中写的都是slf4j的代码\tprivate static final Logger LOG = LoggerFactory.getLogger(EurekaApplication.class);//\tpublic static void main(String[] args) &#123;//\t\tSpringApplication.run(EurekaApplication.class, args);//\t&#125;\tpublic static void main(String[] args) &#123;\t\tSpringApplication app = new SpringApplication(EurekaApplication.class);\t\tEnvironment env = app.run(args).getEnvironment();\t\tLOG.info(&quot;启动成功！！&quot;);\t\tLOG.info(&quot;Eureka地址: \\thttp://127.0.0.1:&#123;&#125;&quot;, env.getProperty(&quot;server.port&quot;));\t&#125;&#125;\n\n然后在resources下新建logback.xml，粘贴上去\nspringboot默认用的日志框架是log back，我们要修改logback的输出格式就要新建logback.xml\n这个文件是一个比较固定的写法\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;!-- 修改一下路径--&gt;    &lt;property name=&quot;PATH&quot; value=&quot;/logs/imooc/course/eureka&quot;&gt;&lt;/property&gt; &lt;!-- 这个是项目所在盘符的根目录，就是比如项目在c盘，就是 c盘/logs.... --&gt;        &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;&lt;!--            &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %highlight(%-5level) %blue(%-50logger&#123;50&#125;:%-4line) %msg%n&lt;/Pattern&gt;--&gt;            &lt;Pattern&gt;%d&#123;ss.SSS&#125; %highlight(%-5level) %blue(%-30logger&#123;30&#125;:%-4line) %msg%n&lt;/Pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;appender name=&quot;TRACE_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;file&gt;$&#123;PATH&#125;/trace.log&lt;/file&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;FileNamePattern&gt;$&#123;PATH&#125;/trace.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;        &lt;/rollingPolicy&gt;        &lt;layout&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level %-50logger&#123;50&#125;:%-4line %green(%-8X&#123;UUID&#125;) %msg%n&lt;/pattern&gt;        &lt;/layout&gt;    &lt;/appender&gt;    &lt;appender name=&quot;ERROR_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;file&gt;$&#123;PATH&#125;/error.log&lt;/file&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;FileNamePattern&gt;$&#123;PATH&#125;/error.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;        &lt;/rollingPolicy&gt;        &lt;layout&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level %-50logger&#123;50&#125;:%-4line %green(%-8X&#123;UUID&#125;) %msg%n&lt;/pattern&gt;        &lt;/layout&gt;        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;            &lt;level&gt;ERROR&lt;/level&gt;            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;        &lt;/filter&gt;    &lt;/appender&gt;    &lt;root level=&quot;ERROR&quot;&gt;        &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt;    &lt;/root&gt;    &lt;root level=&quot;TRACE&quot;&gt;        &lt;appender-ref ref=&quot;TRACE_FILE&quot; /&gt;    &lt;/root&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;&lt;/configuration&gt;\n\n7. 搭建业务模块-system新建system模块，步骤同上\n接下来把system改造成springboot项目，在system的pom中加入依赖\n&lt;dependency&gt;          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;          &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;      &lt;/dependency&gt;\n\n第一个依赖是eureka-client，我们新建的system要作为注册中心的一个客户端\n第二个是springboot的基本的一个依赖\n\n然后把eureka的启动类，application，log文件都拷过来\napplication.properties，名字改成system，端口号改一下\nspring.application.name=systemserver.port=9001\n\nlogback.xml，日志输出目录改一下\n\n启动类名字改成SystemApplication\n把Eureka的注解删除\n\n现在就可以启动成功了，但是没什么结果，我们先建一个controller -&gt; TestController\n随便写个接口\npackage com.course.system.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class TestController &#123;    @RequestMapping(&quot;/test&quot;)    public String test()&#123;        return &quot;success&quot;;    &#125;&#125;\n\n启动项目，访问test ， 看到success说明已经成功\n\n现在system的目录如下：\n\n8. 将system服务注册到注册中心有三步\n\n在system的pom中加入 eureka-client 依赖，之前已经加好了\n\n增加配置，指向注册中心的地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka/\n在启动类中加入注解@EnableEurekaClient\n\n\n\n现在再启动起来，打开Eureka的页面，可以看到端口号9001，已经注册了进来\n\n9. 搭建网关gateway网关的主要功能：\n\n限流：流量控制\n重试：请求失败时重试，慎用\n跨域：前后端不在一个域\n路由：转发请求\n鉴权：登录校验，签名校验等\n\n搭建gateway模块\n首先新建maven子模块，和之前一样\n然后加两个依赖\n一个网关gateway的依赖\n一个注册到注册中心 eureka-client依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\n然后把system的启动类，application.properties，logback.xml都拷过来\n\n启动类改个名\napplication.properties\n名字改成gateway\n端口 9000，因为网关比较特殊，然后其他模块就9001这样往下排\n\n\nlogback  打印地址改成gateway\n\n10 路由转发配置路由转发：将外部请求转发到实际的业务模块进行处理\n在gateway的application.properties中加入配置：\n# 路由转发spring.cloud.gateway.routes[0].id=systemspring.cloud.gateway.routes[0].uri=http://127.0.0.1:9001spring.cloud.gateway.routes[0].predicates[0].name=Pathspring.cloud.gateway.routes[0].predicates[0].args[0]=/system/**\n\n如果有多个  就把routes[0] 改成 routes[1] ,以此类推\n\n第一行是转发到哪一个业务模块（system）\n第二行是业务模块（system）所对应的地址\n后面，我们的路由时基于一个路径的，那么这个路径就是带/system/下面的任何路径都转发到这个路由上去\n\n11 路由转发功能生效现在system的test方法路径是\nhttp://127.0.0.1:9001/test\nhttp://127.0.0.1:9000/system/test是访问不到的\n想让test前面加上/system能够访问到\n在system的application.properties中加一行：\nserver.servlet.context-path=/system\n\n现在访问http://127.0.0.1:9001/system/test就好使了\n\n把端口改9000：\nhttp://127.0.0.1:9000/system/test，也是好使的了\n说明我们的路由转发功能生效了，原来9001的就不会暴露了，暴露的都是网关9000，这样外部只知道一个9000路由，别的不知道，上生产的时候我们可以把9001这个服务器拦截，让外网只能访问9000，之后也会在路由进行权限拦截，限流等功能。\n总结微服务基本的一个架构就是这样子，熟练之后可以先注册中心 -&gt; gateway -&gt;  业务模块\n","categories":[],"tags":["SpringCloud","course"]},{"title":"联合主键问题","url":"/2020/08/03/SSH%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%BB%E9%94%AE%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98/","content":"一.  问题抛出execute error. insert into tr_job_user (user_id, job_id) values (?, ?)java.sql.BatchUpdateException: Duplicate entry &#x27;82151-26182fa5-837d-4ea4-9ad8-813269f13ab5&#x27; for key &#x27;PRIMARY&#x27;\n\n\n\n\n保存的时候就报这个错误，很明显是主键重复的问题，但是这个tr_job_user中间表给user和job多对多关系的，就两个字段，主键也是允许重复的，怎么会出问题呢，最可怕的是这个id也查不到，在什么表里都查不到。\n二. 处理方法在经过各种尝试之后，我还是在数据库走了一下这个insert语句，结果竟然在报错信息中出现了这个id\n\n经过对比后发现，这个id竟然是两个id拼接起来的！\n然后查阅了资料，了解了这种中间表设置的两个主键叫 联合主键，用2个或2个以上的字段组成主键。用这个主键包含的字段作为主键，这个组合在数据表中是唯一，且加了主键索引。\n\n三. 联合主键的创建1.新建表\ncreate table test(    id int(10) not null auto_increment,    name varchar(20) not null,    sex int(1) not null,    primary key (id,name,sex));\n\n2.已有表修改为组合索引\nalter table 表名 add index index_name (name，sex，number);\n\n *****如果执行上面操作提示表不能有多个主键错误时，需要先清理主键约束，再执行添加。\nalter table 表名 DROP PRIMARY KEY add primary key (字段1,字段2,字段3);\n\n","categories":[],"tags":["bug","MySQL"]},{"title":"MySQL更新日期","url":"/2020/07/31/Mysql%E6%9B%B4%E6%96%B0%E6%97%A5%E6%9C%9F/","content":"MySQL时间加减函数为date_add（）、date_sub（）\n\n定义和用法DATE_ADD() 函数向日期添加指定的时间间隔。DATE_SUB() 函数向日期减少指定的时间间隔。\n语法DATE_ADD(date,INTERVAL expr type)DATE_SUB(date,INTERVAL expr type)\n\ndate 参数是合法的日期表达式。\nexpr参数是您希望添加的时间间隔。\ntype 参数可以是下列值：\nType 值MICROSECONDSECONDMINUTEHOURDAYWEEKMONTHQUARTERYEARSECOND_MICROSECONDMINUTE_MICROSECONDMINUTE_SECONDHOUR_MICROSECONDHOUR_SECONDHOUR_MINUTEDAY_MICROSECONDDAY_SECONDDAY_MINUTEDAY_HOURYEAR_MONTH\n\n1. MySQL 为日期增加一个时间间隔：date_add()set @dt = now();select date_add(@dt, interval 1 day);   - 加1天select date_add(@dt, interval 1 hour);   -加1小时select date_add(@dt, interval 1 minute);    - 加1分钟select date_add(@dt, interval 1 second); -加1秒select date_add(@dt, interval 1 microsecond);-加1毫秒select date_add(@dt, interval 1 week);-加1周select date_add(@dt, interval 1 month);-加1月select date_add(@dt, interval 1 quarter);-加1季select date_add(@dt, interval 1 year);-加1年\n\n例：更新某个时间，每个时间加上一个星期\nUPDATE comment c set c.time = DATE_ADD(c.time, INTERVAL 7 DAY) ;\n\n2. MySQL 为日期减去一个时间间隔：date_sub()，格式同date_add（）类似例子：更新某个时间，使每个时间减少一个月\nUPDATE comment c set c.time = DATE_SUB(c.time, INTERVAL 1 MONTH) \n\n3. 工作中的应用比如：修复回复超期问题：\nUPDATE tbb_building_ques SET reply_customer_date = DATE_ADD(submit_date,INTERVAL 20 MINUTE)where quesTask_code in (&#x27;重庆公司20200712760&#x27;)\n\n","categories":[],"tags":["MySQL"]},{"title":"Hexo集成Gitment评论","url":"/2020/07/29/Hexo%E9%9B%86%E6%88%90Gitment%E8%AF%84%E8%AE%BA/","content":"\n博主使用的是**hexo-theme-yilia**主题\n\n\nGitment 是一位作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。\n\n\n\n1. 注册 OAuth Application\n注册一个新的 OAuth Application ➡️ OAuth Application\n\nApplication name 应用名称(根据实际来填写)\nHomepage URL 主页网址(应用程序主页的完整URL)\nApplication description 应用说明(应用描述)\nAuthorization callback URL 授权回调URL(一般是博客的域名)\n\n2. 配置主题注册完成后得到Client ID和Client Secret\n\n修改hexo-theme-yilia主题的配置文件_config.ymlgitment_owner: JoeyBling      #你的 GitHub IDgitment_remote: false  # 是否使用官方js(false可以提升访问速度)gitment_repo: &#x27;yilia-plus-demo&#x27;          #存储评论的 repogitment_oauth:  client_id: &#x27;*********&#x27;           #client ID  client_secret: &#x27;*********&#x27;       #client secret\n\n3. 初始化评论页面发布后，你需要访问页面并使用你的 GitHub 账号登录，点击初始化按钮。\n可能出现的问题我的出现了一个问题，初始化评论的时候一直处于loading comments和logging in…状态。\n\n如果有人出现了这个问题，解决办法是：打开你的blog本地仓库themes\\yilia\\layout\\_partial\\post\\gitment.ejs 将\n&lt;link rel=&quot;stylesheet&quot; href=&quot;//imsun.github.io/gitment/style/default.css&quot;&gt;&lt;script src=&quot;//imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;\n\n修改为：\n&lt;link rel=&quot;stylesheet&quot; href=&quot;https://jjeejj.github.io/css/gitment.css&quot;&gt;&lt;script src=&quot;https://jjeejj.github.io/js/gitment.js&quot;&gt;&lt;/script&gt;\n\n或者修改为下面也ok。\n&lt;link rel=&quot;stylesheet&quot; href=&quot;https://jjeejj.github.io/css/gitment.css&quot;&gt;&lt;script src=&quot;https://www.wenjunjiang.win/js/gitment.js&quot;&gt;&lt;/script&gt;\n\n\n\n\n\n\n参考 ：  https://www.jianshu.com/p/ac7658cc912f\n\n","categories":[],"tags":["hexo"]},{"title":"Hexo添加访问量统计","url":"/2020/07/29/Hexo%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1/","content":"1. 配置是否开启不蒜子访问量统计功能 在themes/yilia/_config.yml添加属性\n# 是否开启访问量统计功能(不蒜子)busuanzi: enable: true\n\n\n\n\n2. 引入不蒜子并添加站点访问量在themes/yilia/layout/_partial/footer.ejs末尾添加如下代码\n&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; %&gt;        &lt;!-- 不蒜子统计 --&gt;        &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;                本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次        &lt;/span&gt;        &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;        &lt;span id=&quot;busuanzi_container_site_uv&quot; style=&#x27;display:none&#x27;&gt;                本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人        &lt;/span&gt;        &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;  &lt;% &#125; %&gt;\n\n\n3. 添加文章访问量在themes/yilia/layout/_partial/post/date.ejs开头添加如下代码\n&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable &amp;&amp; !index)&#123; %&gt;        &lt;!-- 不蒜子统计 --&gt;        &lt;span id=&quot;busuanzi_container_page_pv&quot; style=&#x27;display:none&#x27; class=&quot;&lt;%= class_name %&gt;&quot;&gt;              &lt;i class=&quot;icon-smile icon&quot;&gt;&lt;/i&gt; 阅读数：&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次        &lt;/span&gt;&lt;% &#125; %&gt;\n\n\n4.重启即可看效果\n参考https://www.jianshu.com/p/c9f83d5b893a\n\n","categories":[],"tags":["hexo"]},{"title":"Lock wait timeout exceeded; try restarting transaction","url":"/2020/07/23/Lock-wait-timeout-exceeded-try-restarting-transaction/","content":"\n错误:Lock wait timeout exceeded; try restarting transaction\n\n一 问题抛出删除删不了  即Lock wait timeout exceeded; try restarting transaction的异常，错误提示的意思，很明显，是因为这条语句被锁住了，所以释放这个锁。\n\n\n二 处理方法我们可以通过到information_schema 中来进行查找被锁的语句。\n\n解释：information_schema这张数据表保存了MySQL服务器所有数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。再简单点，这台MySQL服务器上，到底有哪些数据库、各个数据库有哪些表，每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema表里面\n\n我们可以用下面三张表来查原因：\n\ninnodb_trx 当前运行的所有事务\ninnodb_locks 当前出现的锁\ninnodb_lock_waits 锁等待的对应关系\n\n如果数据库中有锁的话，我们可以使用这条语句来查看：\nselect * from information_schema.innodb_trx\n查看trx_rows_locked 这一列 如果是大于0的话，说明是堵塞住了， 然后查对应的trx_mysql_thread_id 列\n看到一个线程ID， \n然后执行SQL , kill 线程ID 即可\n","categories":[],"tags":["bug"]},{"title":"Redis初识","url":"/2020/07/15/Redis%E5%88%9D%E8%AF%86/","content":"Redis\n\nRedis支持的数据类型及特性支持的数据类型：\nString\nList：列表，也可以理解为队列，用于存储序列结合，redis中的list是双向链表实现的，通过push，pop操作可以从链表的头部和尾部添加和删除数据。\nHash：哈希，redis中叫做字典，用于存储多个K V 数据，而且这些K V 数据是一类的，比如个人信息 年龄 性别等，可以想象成hashmap去使用。\nSet：无序的方式存储不同的元素，对元素进行快速的添加 修改和删除，相同的元素算一个。\nSortedSet：每个元素都关联一个浮点型的权重值，根据权重值去获取元素，如果权重相同按字节排序去获取，最常应用排行榜，存储系统中的所有用户，把每个用户的积分设置为权重值。\n\n特性\nRedis所有的操作都是原子的\n数据库事务原子性指的是 一个事务要么全部完成，要么全部不完成，不会结束在中间的某个环节。redis的操作原子性指的是一个操作不可以细分，操作要么执行要么不执行，redis操作是原子的是因为redis是单线程的 。\n\nRedis可以对Key设置过期时间 \n\n定时删除：在设置键的过期时间的同时设置一个定时器，让定时器在键的过期时间到来的时候立即执行对键的删除操作，也就是在设置key的过期时间开始就启动一个定时器，到时间就删除这个key，对内存友好，但是会浪费cpu资源。\n\n惰性删除：放任键不管，但是每次从键空间取的时候都会检查键是否是过期的，过期就删除，对cpu友好，但是浪费内存资源，而且这个key永远不使用了就会一直在 。\n\n定期删除：一段时间程序对数据库进行检查，删除里面的过期key。至于删除多少，以及检查多少数据库，则是由算法决定的，比如设置一个定时任务，间隔小呢浪费cpu，间隔大呢浪费内存 。\nredis服务器使用的是后两种删除策略 \n\n\n\nRedis支持两种持久化方式\nredis为了内存数据的安全考虑，会把本身的数据按照文件的形式存储在磁盘中，在服务器重启后会自动把磁盘的数据保存到内存中，数据保存到磁盘的过程就是持久化\n\nRDB（快照、默认）：默认开启，一次性把redis所有数据都存到硬盘，但是数据量非常大就不适用，实际上很少用这种方式。\nAOF：把用户执行的每一个写指令（添加，修改，删除）都备份到文件中，还原数据的时候执行下指令，企业级都使用AOF。\n\n\nRedis速度快的原因\n\n完全基于内存\n数据结构简单\n单线程，没有切换\n多路IO复用模型：利用select，poll，epoll这样的一些系统函数，可以同时监查多个流IO的能力，空闲的时候把当前的线程阻塞掉，当一个或多个流有io事件的时候，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流，epoll只是轮询那些真正发生事件的流，select会轮询所有的流，并且依次顺序的处理就绪的流，这种做法呢就避免了大量的无用操作。\n\n\n\n\nRedis 是单线程+多路IO复用技术多路复用：使用一个线程来检查多个文件描述符的就绪状态\n　　　　　如果有一个文件描述符就绪，则返回\n　　　　　否则阻塞直到超时\n　　　　　得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（线程池）\n　　　　　本质上是没有阻塞的\n\n阻塞lO（串行）：给女神发一条短信, 说我来找你了,然后就默默的一直等着 女神下楼,这个期间除了等待你不会做其他事情,属于备胎做法.\n非阻塞IO：给女神发短信，如果不回,接着再发,一直 发到女神下楼,这个期间你除了发短信等待不会做其他事情,属于专-做法.\nIO多路复用：是找一个宿管大妈来帮你监视下楼的女生,这个期间你可以些其他的事情.例如可以顺便看看其他妹子,玩玩王者荣耀,上个厕所等等.\n\nIO复用又包括select, poll, epoll模式那么它们的区别是什么?\nselect：\n\n　　一个女生下楼, select大妈都不知道这个是不是你的女神，她需要一个一 个 询问，并且select大妈能力还有限，最多一次帮 你监视1024个妹子\n\npoll：\n\n　　poll大妈不限制盯着女生的数量，只要是经过宿舍楼门口的女生，都会帮你去问是不是你女神\n\nepoll:\n\n　　epoll大妈不限制盯着女生的数量，并且也不需要一个- 个去问.那么如何做呢? epol1大妈会为每个进宿舍楼的女生脸上贴上一一个大字条,上面写上女生自己的名字,只要女姓下楼了, 　　eoll大妈就知道这个是不是你女神了,然后大妈再通知你.\n​                                                     https://www.cnblogs.com/zly123/p/11729034.html \n\n常见问题缓存穿透和缓存雪崩的问题\n缓存穿透\n指的是用户去查数据，数据库中没有所以缓存中也没有，这样就会导致用户在缓存中查询找不到，每次都会再去数据库查一遍然后返回一个空，这样就相当于进行了两次无用的查询，由于这样的请求绕过了缓存直接去查数据库，这也是经常提到的缓存命中率的问题。\n解决方案：\n\n给没有命中的key设定“没有意义的空值”，通过设置的这个默认值存放到缓存里，这样就会查到一个没有意义的值，而不会继续去访问数据库。\n布隆过滤器： 对所有可能查询的参数以hash形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询。 \n\n\n缓存雪崩\n由于原有的缓存失效，新的缓存又没有生成，比如设置缓存时采用了相同的过期时间，在同一时间出现了大量的缓存过期，所有应该访问缓存的请求都会查询数据库，而对数据库，cpu和内存造成巨大的压力导致数据库宕机，造成雪崩。\n解决方案：\n\n给key设置不同（随机）的过期时间\n\n\n缓存击穿\n是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。 \n解决方案：\n\n使用互斥锁(mutex key)\n业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。\nSETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。\n\n大道至简，设为永不过期。\n\n\n\n\nRedis - I/O模型\n阻塞模型的特点：当read/write对某一个文件描述符（FD）进行读写时，如果当前的FD不可读或不可写，则服务堵塞\n\n\n多路复用模型的特点：同时监控（select/epoll）多个文件描述符的可读可写情况，当其中的某个文件描述符可读或者可写时，就会返回可读以及可写的文件描述符（个数）\n \n\nRedis的Reactor设计模式：将不同的IO复用模块函数 封装成相同的API，提供给上层去使用，可以让redis能够以单线程运行的同时 去服务成千上万个文件描述符（客户端）\n \n\n\n","categories":[],"tags":["redis"]},{"title":"git详细教程","url":"/2020/03/17/Git/","content":"\n\n一、准备git环境​            安装包下载地址：https://git-scm.com/downloads\n​            安装教程：\n​        https://www.cnblogs.com/wj-1314/p/7993819.html\n连接GitHub：配置全局邮箱\ngit config --global  user.email  GitHub上的邮箱地址\n\n\n配置全局用户名\ngit config --global user.name GitHub上的用户名\n\n\n记住密码（push第一次输入密码之后就无须再输入了）\ngit config --global credential.helper store\n\n\n\n\n\n​            至此git已经与GitHub账号绑定\n查看配置信息1、查看git配置信息\ngit config –list\n2、查看git用户名\ngit config user.name\n3、查看邮箱配置\ngit config user.email\n二、GitHub基本操作使用​            https://github.com\n1、新建仓库（1）点击new新建一个仓库\n（2）点击根据提示完成仓库配置\n（3)获取地址，此地址为仓库地址\n2.GitHub权限控制\nAdmin 管理者权限(只能 read、clone、push、给仓库添加成员 )\nWrite 项目合作者写权限(只能 read、clone、push)\nRead 游客读权限(只能 read、clone) \n\n设置某一分支的权限\n\n三、git的基本操作状态分类\n未被Git跟踪的状态为unstage状态；\n已被Git跟踪的状态为stage状态（stage：阶段），因此包括staging状态和staged状态。\n\n​      untrack files：是指尚未被git所管理的文件；changed but not updated：是指文件被git管理，并且发生了改变，但改动还没被git管理；这两种状态，都可以看成是改动还没被git管理的状态，我们这里称unstage状态。staging是commit和未管理之间的一个状态，也有别名叫index状态，也就是git已经管理了这些改动，但是还没完成提交。changes to be commited是指进入staged状态的文件。.gitignore中的文件，不会出现在以上三个状态中。\n1、创建版本库本地新建一个文件夹作为本地的git仓库用来与Git交互\n进入到该路径\n\n执行生成.git文件\ngit init \n\n\n2.管理仓库连接（1）连接一个需要连接的远程仓库git remote add origin https://github.com/zhang09090606/test.git\n其中origin是作为本地的连接该仓库的连接名，以后使用该仓库可以直接使用origin\n（2）查看本地的所有连接名称git remote    \n\n查看本地连接详细属性包括地址\ngit remote -v\n\n3.提交项目到远程需求：将这两个文件提交到远程\n\n（1）git add 操作命令将文件内容添加到索引(将修改添加到暂存区)。也就是将要提交的文件的信息添加到索引库中。\n​        git add .            提交全部文件\n​        git add 文件名    提交指定文件\n4.查看文件状态git status\n 未有add红色字体，未有commit绿色字体，已提交则worktree是干净的\n\n5.向版本库提交　git commit –m “XXXX”     #提交修改,添加注释\n​    \n6.撤销修改　（1）git reset  会将所有stage的文件状态，都改变成非stage状态。\n​    （2)git reset –hard sdv143kvf…… #可回到指定的版本#(hard后面为每次提交系统自\n动生成的一串哈希值)\n​      (3)git reset [path] 会改变path指定的文件或目录的stage状态，到非stage状态。\n​      (4)git reset –hard  #回到原来编辑的地方,改动会丢失。（同样适用于团队对于其他人\n的修改恢复）\n(5)撤销某次修改 回退1个change的写法就是git reset HEAD^，2个为HEAD^^，3个为HEAD~3，以此类推。\n如果撤销错了怎么办？git reflog方法查看所有提交\n\n然后通过 上面的git reset –hard方法还原到指定提交的版本\n7.查看版本信息git log    展示所有提交信息\ngit log –oneline 查看每次commit的备注信息\ngit log --name-status找到对应版本号，执行后可以看到本次提交之前的所有修改文件。\n删除log方法：常用的新建一个分支作为临时分支，然后删除原来的，然后把这个分支改名成原来的分支\n创建临时分支\ngit checkout --orphan tmp\n\n添加所需提交的文件\ngit add -A\n\n添加commit信息\ngit commit -m &quot;Clean Log&quot;\n\n删除master分支\ngit branch -D master\n\n更名分支\ngit branch -m master\n\n提交新的master分支代码\ngit push -f origin master\n\n8.向远程仓库推送修改　git push 仓库的名称 远程分支名\n\n9.将远程项目合并到本地项目git pull方法将远程的分支合并到本地当前分支\ngit pull origin 远程分支名\n\n将远程的分支合并到本地指定分支\ngit pull origin 本地指定分支名:远程分支名\n\n\n\ngit fetch方法使用远程分支在本地创建分支(但不会切换到该分支),如果本地不存在本地该名称分支, 则会自动创建一个新的本地分支,如果本地存在该名称分支, 并且是可以快进合并, 则自动合并两个分支, 否则, 会阻止\ngit fetch origin 远程分支名:本地分支名\n\n\ngit pull 和 git fetch 有什么区别git pull 命令从中央存储库中提取特定分支的新更改或提交，并更新本地存储库中的目标分支。\ngit fetch 也用于相同的目的，但它的工作方式略有不同。当你执行 git fetch 时，它会从所需的分支中提取所有新提交，并将其存储在本地存储库中的新分支中。如果要在目标分支中反映这些更改，必须在 git fetch 之后执行git merge。只有在对目标分支和获取的分支进行合并后才会更新目标分支。为了方便起见，请记住以下等式：\ngit pull = git fetch + git merge\n10.从远程克隆项目git clone 远程路径\n\n\n\ngit clone与git pull区别从远程服务器克隆一个一模一样的版本库到本地,复制的是整个版本库，叫做clone.（clone是将一个库复制到你的本地，是一个本地从无到有的过程）从远程服务器获取到一个branch分支的更新到本地，并更新本地库，叫做pull.（pull是指同步一个你在本地有版本的库内容更新的部分到你的本地库）\n11.暂存　　git stash可以把当前的改动（stage和unstage，但不包括untrack的文件）暂存。\n　　然后通过git stash list查看。\n​        git stash pop取出栈顶被储藏修改的元素\n　　并通过git stash apply重新取出来。但apply之前要保证worktree是干净的。\n12.忽略设置在项目开发中，我们使用git托管项目时往往会忽略一些不必要的文件或文件夹，下面我们来介绍下忽略文件和文件夹的\n（1）在版本库根目录右键选择git Bash here输入\n​            touch .gitignore\n​        生成.gitignore文件\n（2）修改文件，添加忽略正则，书写例子如下：\n注意：#为注释，正则中的*不要忘了加,最后不要忘了也要忽略.gitignore本身\n#忽略.idea文件夹及文件夹下文件        .idea        #忽略以.iml结尾的文件        *.iml        # 忽略*.o和*.a文件        *.[oa]        # 忽略*.b和*.B文件，my.b除外        *.[bB]        !my.b        # 忽略dbg文件和dbg目录        dbg        # 只忽略dbg目录，不忽略dbg文件        dbg/        # 只忽略dbg文件，不忽略dbg目录        dbg        !dbg/        # 只忽略当前目录下的dbg文件和目录，子目录的dbg不在忽略范围内        /dbg        # 以&#x27;#&#x27;开始的行，被视为注释.        * ？：代表任意的一个字符        * ＊：代表任意数目的字符        * &#123;!ab&#125;：必须不是此类型        * &#123;ab,bb,cx&#125;：代表ab,bb,cx中任一类型即可        * [abc]：代表a,b,c中任一字符即可        * [ ^abc]：代表必须不是a,b,c中任一字符\n\n例：\n总结：提交流程：修改代码 -&gt; git add . -&gt; git commit -m “” -&gt; git push 仓库的名称 远程分支名\n从远程下载流程：全部拷贝git clone，仅合并分支git pull\n三、分支（branch）1.定义书面版：几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。\n白话版：分支就是把一个文件夹分层，虽然文件夹还是一个，但是切换到每一层都可以不一样，对其中一层操作时其他层不会受到影响\n2.分支的应用：开发时我们从项目从远程端拷下来后，可以创建一个分支当做开发分支，然后切换到该分支进行开发开发测试完毕后再合并到主分支再提交，这样即便开发错了也不会对之前的版本造成任何影响，还可以创建多个分支，阶段测试等功能\n3.git分支优点：创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次\n4.分支的基本操作（1）创建分支​            \ngit branch 分支名字\n\n\n​            创建的分支会拷贝当前所在分支的所有文件\n(2)查看所有分支​    \ngit branch\n\n\n其中带*并且是绿色的就是当前所在分支\n（3）切换分支：​    \ngit checked 要切换到的分支名称\n\n\n注意事项！！！！切换分支之前一定要将分支内的新建文件都git add+git commit，不然会直接同步到其他分支！！！\n（4）删除分支：git branch -d 分支名\n\n\n（5）恢复删除的分支git reflog\n\n找到所有删除分支的散列值\n\ngit branch 删除的分支名 HEAD@{对应的数字}\n\n（6）清理提交对象​    删除除了当前分支之外的所有提交\ngit gc\n\n\n（7）合并分支将此分支的所有不同的更改全部合并到当前分支\ngit merge branch1\n\n\n四、冲突1.冲突的发生条件合并时两个分支，同时对一个文件的同一行代码进行了不同的修改，\n例：\n\n当前分支和branch1分支同时对t1文件进行修改所以合并的时候报冲突错误\n2.冲突的解决办法（1）通过手动编辑冲突文件git status获取到未成功合并的冲突文件\n\n打开该文件\n\n=======上下是冲突的两部分\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD与=======是本分支的\n=======的另一部分是需合并分支的\n删除其中一部分的文件即可\n\n\n（2）对于一些二进制文件是无法自己编辑的保留本分支的提交\ngit checkout 文件名 --ours\n\n保留本分支的提交\ngit checkout 文件名 --theirs\n\n\n注意：文件名一定要加上后缀，解决冲突后需要重新git add和git commit提交\n3.撤销合并分支撤销最近的一次合并分支\ngit reset --merge\n\n4.快进合并如果当前的分支和另一个分支没有内容上的差异，就是说当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作；git 不创建任何新的提交(commit),只是将当前分支指向合并进来的分支。\n说白了就是你所在的分支上所有东西想合并的分支都有，并且还比你多一些，就可以使用快进合并\ngit merge –no-ff \n\n\n五、变基（rebase）1.工作原理变基也是合并代码的一种手段。变基与合并(Merge)不同的是，他可以修改历史，使用rebase来代替merge合代码的话，得到的历史记录是一条直线提交历史，无分叉，很漂亮。然而这也是它的缺点，它抹去了分支历史信息，无法追溯。\n简单说变基工作就是相当于把要合并的分支上的所有修改提交，在本分支上实现一遍， 就像重新播放一样\n2.变基的存在意义虽然最后整合得到的结果没有任何区别，但变基能产生一个更为整洁的提交历史。如果视察一个变基过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。\n3.变基的操作git rebase branch1\n\n\n4.变基的注意事项变基要在自己本地仓库中拉出来的分支使用，不要对本地仓库外有副本的分支执行变基\n也就是说变基本质上是一个完全在本地仓库进行的操作，我们往往是在本地执行完成变基操作后，再向远程仓库push。这样做，避免了其他合作者的处理冲突，其他合作者只需要利用git merge自身的fast-forward即可完成Merge的工作。\n综上，变基适用于多人线上合作开发的场景，避免其他合作者处理冲突，例如github上开源项目的维护。公司内部因为地理上、组织上的便利性，可以酌情使用变基。\n5.遇到冲突情况变基与合并一样同样会遇到冲突情况，解决冲突办法也同合并一样，但是由于变基是线性的，所以会造成遇到冲突之前的文件已经变基成功了，需要我们执行继续变基\ngit rebase --continue\n\n六、团队合作1.添加项目合作者\n添加完成以后，点击“Copy invite link”，然后复制该邀请链接给邀请的人员，如下图所示：\n\n合作者会收到邀请邮件或者直接访问此网址点击同意即可建立合作者关系\n2.创建新的远程分支原则上每个合作者都要有一个自己的远程分支，避免影响到主分支\nGitHub无法在网页上创建新的分支，只能再本地创建远程分支\n操作方法：git push  远程主机名称 本地分支名称:要新建的远程分支名称\n这时候git将会检测远程是否含有该分支名的分支，没有将会创建一个新的，同时将本地文件上传到该分支上\n\n3.删除远程分支git push 远程主机名 –detete 删除分支名\n\n4.组员合并拉取请求1.方法一项目成员上传项目到本分支后，github会提示是否向项目拥有者提交合并分支的请求\n\n点击绿色按钮确定后\n2.方法二\n点击new pull request\n\n设置好参数后确认提交，等待组长拉取请求\n此时千万不要点击merge pull request，不然就直接合并了，组长也不会收到提示，一定要等待组长来点击！！！！5.项目拥有者确认拉取分支组员提交拉取请求后，组长会在pull requests里看到一条新的拉取请求\n\n点击new pull request新建合并\n\n同意设置好属性点确定\n\n此时GitHub会检查两个分支是否存在冲突，存在会提示手动修改，不存在的话将会提示没问题可以拉取\n\n最后点击merge pull request成功拉取请求，至此两个分支就合并完成了\n项目合作注意事项！！！1.一个组员对应一个分支\n2.每天组员工作前都要先Git pull或者Git fetch一下更新本地的版本，\n然后进行开发组长安排好的模块\n3.组长安排尽量不两个人开发同一文件，即便不得已开发同一文件也不要修改同一行代码避免发生冲突\n4.组员通过git add git commit提交到本地仓库之后，需要提交到\n5.除了组长任何人不得直接修改操作master分支，可以通过权限进行控制\n6.本地仓库同样需要建立一个新的分支，而不要直接在本地的master分支上进行开发，分支命名尽量与远程分支上分配的名字一致方便记忆\n——来自技术分享，张博文\n","categories":[],"tags":["技术分享","git"]},{"title":"配置路由","url":"/2020/03/11/%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/","content":"表：ts_function_menu\n父节点：参考他旁边的，复制过来自己改个id，改个menu_name\n子节点：复制个他附近的，改点东西\n\nid 一般是父节点id再累加    \nparent_id 就是父节点id  \nmenu_router前端给你发的那玩意\nmenu_name改好\nmenu_type 和前端商量好\nmenu_order 就是他在列表的位置\n\n然后去ts_function_menu_new 加上\n然后去ts_menu_button 加上菜单权限\n最后去tr_role_menu表中，把id加进去，就可以在环境中看到了\n还没弄明白可以参考接口\nhttp://120.27.194.131:8888/zs-mkf/rest/postInfo/getFunctionButtonsuserId: 4230BC6E-69E6-46A9-A39E-B929A06A84E8menuTypes: 0\n\n","categories":[],"tags":["bug"]},{"title":"修复数据库字段","url":"/2019/12/09/%E4%BF%AE%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5/","content":"– 修复tbb_building_ques中room_part_name字段UPDATE tbb_building_ques a,sl_room_part bSET a.room_part_name = b.room_part_nameWHERE a.room_part_id = b.room_part_id;\n","categories":[],"tags":["MySQL"]},{"title":"idea从svn拉拽的ssh项目搭建","url":"/2019/11/25/idea%E4%BB%8Esvn%E6%8B%89%E6%8B%BD%E7%9A%84ssh%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","content":"\n\n一. 从svn拉取项目等待右下角进度条走完，现在目录结构是这样的\n\n二 修改配置1. 改数据库配置shift shift  找jdbc，改数据库连接配置\n\n进去之后改ip、端口、数据库名、username和password\n2. 改jdk配置\n\n注意：上面是几 下面就是几 要对上\n3. 改Modulesweb\n上面的改成web.xml路径，下面的改成webapp路径\n\n加hibernate\n\n找到hibernate的xml文件\n\n加spring\n\n\n4. 添加lib\n\n然后去tomcat根目录下找lib 不要选c开头的4个\n\n5. 改Artifacts\n选完ok就行了\n最后是配置tomcat\n\n\n然后就可以跑起来啦！\n遇到异常，该注释的注释！\n常见问题\n注意jdk版本以及下面和它对应的也要修改\n\n运行报错：\nException in thread &quot;commons-pool-EvictionTimer&quot; Exception in thread &quot;RMI TCP Connection(idle)&quot; Exception in thread &quot;RMI TCP Connection(idle)&quot; 2019-11-25 15:53:22,295 ERROR (DefaultSingletonBeanRegistry.java:513)- Destroy method on bean with name &#x27;requestSoapXmlDao&#x27; threw an exceptionjava.lang.OutOfMemoryError: PermGen spaceException in thread &quot;RMI TCP Connection(idle)&quot; Exception in thread &quot;RMI TCP Connection(idle)&quot; 2019-11-25 15:55:56,153 ERROR (DefaultSingletonBeanRegistry.java:513)- Destroy method on bean with name &#x27;requestInfoService&#x27; threw an exceptionjava.lang.OutOfMemoryError: PermGen space\n\n解决办法：把下面这段话粘到如下地方\n-Xms128m -Xmx512m -XX:PermSize=128m -XX:MaxPermSize=128m\n\n\n\n\n\n\n","categories":[],"tags":["ssh"]},{"title":"什么是RESTful","url":"/2019/11/20/%E4%BB%80%E4%B9%88%E6%98%AFRESTful/","content":"\n\nRESTful风格概述什么是RESTful？REST：Representational State Transfer（表述性状态转移）\nREST并不是一种创新技术，它指的是一组架构约束条件和原则\n符合REST的约束条件和原则的架构，就称他为RESTful架构\nRESTful核心内容\n资源与URI\n表述性状态转移，指的就是资源的表述。那么什么是资源呢？\n在一个系统中，只要一个事务有被引用的必要，那么它就是一个资源\n它可以是一个文本，可以是一首歌曲，也可以是一个服务，总之是一个真实存在的资源\n那么让资源可以被识别，就需要有一个唯一标识，也就是URI，URI就是资源的地址\n\n资源的表述\n资源在客户端和服务器之间传送\n\n状态转移\n指资源在客户端发生变迁，然后进入到一个后续的状态，客户端获取资源之后，可能会对资源进行修改，使他跟咱们在服务器保存的状态不一样，那么这个就是状态转移\n\n\nRESTful架构的特点\n统一了客户端访问资源的接口\nurl更加简洁，易于理解，便于扩展\n有利于不同系统之间的资源共享\n\nRESTful具体来说就是HTTP协议的四种形式表示四种基本操作\n\n\n\nMethod\nCRUD\n\n\n\nGET\n获取资源\n\n\nPOST\n新建资源\n\n\nPUT\n修改资源\n\n\nDELETE\n删除资源\n\n\nRESTful开发风格demo：\n查询课程：http://localhost:8080/id method=’get’\n// 通过id查询课程Controller:@GetMapping(value=&quot;/getById/&#123;id&#125;&quot;)public ModelAndView getById(@PathVariable(value=&quot;id&quot;) int id)&#123;\tModelAndView modelAndView = new ModelAndView();\tmodelAndView.setViewName(&quot;edit&quot;);\tmodelAndView.addObject(&quot;course&quot;,courseDAO.getById(id));\treturn modelAndView;&#125;前端:&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/getById/$&#123;course.id&#125;&quot; method=&quot;get&quot;&gt;\n\n\n\n添加课程：http://localhost:8080/course method=’post’\n@PostMapping(value=&quot;/add&quot;)public String add(Course course)&#123;\tcourseDAO.add(course);&#125;\n\n\n\n删除课程：http://localhost:8080/id method=’delete’\n@DeleteMapping(value=&quot;/delete/&#123;id&#125;&quot;)&#123;\tcourseDAO.deleteById(id);\treturn &quot;redirect:/getAll&quot;;&#125;\n\n\n\n修改课程：http://localhost:8080/course method=’put’\n@PutMapping(value=&quot;/update&quot;)public String update(Course course)&#123;\tcourseDAO.update(course);\treturn &quot;redirect:/getAll&quot;;&#125;\n\n","categories":[],"tags":["SpringMVC","RESTful"]},{"title":"初识MyBatisPlus","url":"/2019/11/20/%E5%88%9D%E8%AF%86MyBatisPlus/","content":"初识MyBatisPlus\n\nMyBatis优势：\n\nSQL语句可以自由控制，更灵活，性能较高\nSQL与代码分离，易于阅读和维护\n提供XML标签，支持编写动态SQL\n\nJPA优势：\n\nJPA移植性较好（JPQL）\n提供了很多CRUD方法，开发效率高\n对象化程度更高\n\n对比后MyBatis劣势：\n\n简单CRUD操作还得写SQL语句\nXML中有大量的SQL要维护\nMyBatis自身功能优先，但支持Plugin\n\n那么，有没有一种框架，既有MyBatis的种种好处，又拜托了MyBatis的劣势呢？\nMyBatis-Plus简介MP是一个MyBatis的增强工具，只做增强不做改变\n地址： https://mp.baomidou.com/ \n性能介绍：\n\n无侵入，损耗小，强大的CRUD操作\n支持Lambda形式调用，支持多种数据库\n支持主键自动生成，支持ActiveRecord\n支持自定义全局通用操作，支持关键词自动转义\n内置代码生成器，内置分页插件，内置性能分析插件\n内置全局拦截插件，内置sql注入剥离器\n\n基本使用通用mapper新增方法SSM传统编程模式：\n接口中写抽象方法 -&gt; XML或注解写SQL -&gt; Service中调用接口 -&gt; Controller中调用\nmp新增demo：\nUserMapper.java:\npublic interface UserMapper extends BaseMapper&lt;User&gt;&#123;&#125;\n\nInsertTest.java:\n@RunWith(SpringRunner.class)@SpringBootTestpublic class InsertTest&#123;\t@Autowired\tprivate UserMapper userMapper;\t\t@Test\tpublic void insert()&#123;\t\tUser user = new User();\t\tuser.setName(&quot;小明&quot;);\t\tuser.setAge(13);\t\t\t\tint rows = userMapper.insert(user);\t&#125;&#125;\n\n常用注解User.java 实体类\n@Data@TableName(&quot;mp_user&quot;)  // 直接指定对应的数据库表叫什么名 不加的话User默认对应user表 这个代表User对应mp_user表public class User&#123;\t@TableId\t// 指定userId就是对应数据库中的主键\tprivate Long userId;\t\t// 指定realName在数据库中对应name列  要不然都是默认实体驼峰对应数据库下划线\t@TableField(&quot;name&quot;)\tprivate String realName;\t\tprivate Integer age;&#125;\n\n\n\n排除非表字段的三种方式场景：实体中某个变量不对应表中任何一个字段，他只是暂时存一些数据或者保存通过某种计算或组装的数据\ndemo:     给实体类添加一个数据库没有的变量\n// 实体类中添加一个数据库没有的字段 用来暂时存一些数据private String remark;————————————————————————————————————————————————————————————————————————// 测试类设置属性值@Testpublic void insert()&#123;\tUser user = new User();\tuser.setName(&quot;小白&quot;);\tuser.setAge(11);\t\tuser.setRemark(&quot;我是一个备注信息~&quot;);\tint rows = userMapper.insert(user);&#125;\n\n这是不成功的，因为数据库中没有remark字段，解决办法有三种：\n\n加关键字transient\n// 实体类中给变量添加关键字private transient String remark;\n\n缺点：加了这个字段不参与序列化了，有序列化的需求用第二种方法\n\n把它标识为静态变量static\n// 实体类中给变量标识为静态变量private static String remark;————————————————————————————————————————@Testpublic void insert()&#123;\tUser user = new User();\tuser.setName(&quot;小猪&quot;);\tuser.setAge(11);\t\t// 因为用的static 所以要用类名.\tUser.setRemark(&quot;我是一个备注信息~&quot;)\t\tint rows = userMapper.insert(user);&#125;\n\n注意：\n1. Lombok不会为静态变量声明get set 方法，需要手动生成\n\n2. 因为用的static，所以调用要用类名.方法名\n\n缺点：这样是全类唯一一份remark，要想每个对象对应一个remark，用第三种\n\n用@TableField(exist=false)\n// 这个注解exist默认为true，写成false表示不是数据库表中的字段@TableField(exist=false)private String remark;\n\nMP查询方法普通查询@RunWith(SpringRunner.class)@SpringBootTestpublic class RetrieveTest&#123;\t@Autowired\tprivate UserMapper userMapper;\t\t// 根据id查user\t@Test\tpublic void selectById()&#123;\t\tUser user = userMapper.selectById(&quot;343523452342L&quot;);\t\tSystem.out.println(user);\t&#125;\t\t// 根据多个id查user\t@Test\tpublic void selectByIds()&#123;\t\tList&lt;Long&gt; idsList = Arrays.asList(412343543542342L,24234235142143L,254453245254L);\t\tList&lt;User&gt; userList = userMapper.selectBatchIds(idsList);\t\tSystem.out.println(user);\t&#125;\t\t// map查询\t@Test\tpublic void selectByMap()&#123;\t\tMap&lt;String,Object&gt; map = new HashMap&lt;&gt;();\t\tmap.put(&quot;name&quot;,&quot;小李&quot;);\t\tmap.put(&quot;age&quot;,12);\t\tList&lt;User&gt; userList = userMapper.selectaByMap(map);\t\t// SQL语句应该是 select 所有字段 from user where name=&quot;小李&quot; and age=12\t\t// 注意map中的键对应的是数据库中的列 不是实体的属性名\t\t\t\tuserList.forEach(System.out::println);\t&#125;&#125;\t\n\n\n\n条件构造器查询// 1. 名字中包含雨并且年龄小于40// name like &#x27;%雨%&#x27; and age&lt;40@Testpublic void selectByWrapper()&#123;\tQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();\t//或者可以写成 QueryWrapper&lt;User&gt; queryWrapper = Wrappers.&lt;User&gt;query();\t\tqueryWrapper.like(&quot;name&quot;,&quot;雨&quot;).lt(&quot;age&quot;,40);\t// 键同样是数据库列名，lt是小于        List&lt;User&gt; userList = userMapper.selectList(queryWrapper);    userList.forEach(System.out::println);\t&#125; \n\n// 2. 名字中包含雨并且年龄大于等于20且小于等于40并且email不为空// name like &#x27;%雨%&#x27; and age between 20 and 40 and email is not null@Testpublic void selectByWrapper()&#123;\tQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();\t\tqueryWrapper.like(&quot;name&quot;,&quot;雨&quot;).between(&quot;age&quot;,20,40).isNotNull(&quot;email&quot;);        List&lt;User&gt; userList = userMapper.selectList(queryWrapper);    userList.forEach(System.out::println);\t&#125; \n\n// 3. 名字中为王姓或者年龄大于等于25，按照年龄降序排列，年龄相同按照id升序排列// name like &#x27;王%&#x27; or age&gt;=25 order by age desc,id asc@Testpublic void selectByWrapper()&#123;\tQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();\t\t\t queryWrapper.likeRight(&quot;name&quot;,&quot;王&quot;).or().ge(&quot;age&quot;,25).orderByDesc(&quot;age&quot;).orderByAsc(&quot;id&quot;);        List&lt;User&gt; userList = userMapper.selectList(queryWrapper);    userList.forEach(System.out::println);\t&#125; \n\nselect中字段不全部查询// select id,name from user where name like &#x27;%雨%&#x27; and age&lt;40@Testpublic void selectIdAndName()&#123;\tQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();\tqueryWrapper.select(&quot;id&quot;,&quot;name&quot;).like(&quot;name&quot;,&quot;雨&quot;).lt(&quot;age&quot;,40);\t\tList&lt;User&gt; userList = userMapper.selectList(queryWrapper);\tuserList.forEach(System.out:：println);&#125;\n\n// 如果有很多字段，然后要排除其中的一个两个字段@Testpublic void selectIdAndName()&#123;\tQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();\t// 查找除create_time 和 manager_id字段的其他字段的值，其他条件和上一个一样\tqueryWrapper.select(User.class,info-&gt;!info.getColumn().equals(&quot;create_time&quot;)&amp;&amp;!info.getColumn().equals(&quot;manager_id&quot;)).like(&quot;name&quot;,&quot;雨&quot;).lt(&quot;age&quot;,40);\t\tList&lt;User&gt; userList = userMapper.selectList(queryWrapper);\tuserList.forEach(System.out:：println);&#125;\n\n条件构造器中condition使用场景：表示该条件是否加入最后生成的SQL中，如果为true就加入，如果为false就不加入\n比如前端给你传值 传过来的sql就加进去，没有传的sql就不写，类似动态sql那种\nprivate void condition(String name,String email)&#123;\tQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();\tif(StringUtils.isNotEmpty(name))&#123;\t\tqueryWrapper.like(&quot;name&quot;,name);\t&#125;\tif(StringUtils.isNotEmpty(email))&#123;\t\tqueryWrapper.like(&quot;email&quot;,email);\t&#125;\t\tList&lt;User&gt; userList = userMapper.selectList(queryWrapper);\tuserList.forEach(System.out::println);\t&#125;@Testprivate void testCondition()&#123;\tString name = &#x27;王%&#x27;;\tString email = &#x27;&#x27;;\tcondition(name,email);&#125;\n\n这样写没有问题，但是太麻烦，可以用带condition的like\nprivate void condition(String name,String email)&#123;\tQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();\tqueryWrapper.like(StringUtils.isNotEmpty(name),&quot;name&quot;,name).like(StringUtils.isNotEmpty(email),&quot;email&quot;,email);\t\tList&lt;User&gt; userList = userMapper.selectList(queryWrapper);\tuserList.forEach(System.out::println);&#125;@Testprivate void testCondition()&#123;\tString name = &#x27;王%&#x27;;\tString email = &#x27;&#x27;;\tcondition(name,email);&#125;\n\n创建条件构造器时传入实体对象@Testpublic void selectByWrapperEntity()&#123;\tUser whereUser = new User();\twhereUser.setName(&quot;小刘&quot;);\twhereUser.setAge(32);\t\tQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();\tList&lt;User&gt; userList = userMapper.selectList(queryWrapper);\tuserList.forEach(System.out::println);&#125;\n\n有时候前端都是要like，不是等值的\n修改实体类 加注解\n@Datapublic class User&#123;\tprivate Long id;\t// like\t@TableField(condition=SqlCondition.LIKE)\tprivate String name;\t// 小于\t@TableField(condition=&quot;%s&amp;lt;#&#123;%s&#125;&quot;)\tprivate Integer age;&#125;\n\n这样你写完直接就是like的，然后age就是小于\nallEq用法@Testpublic void selectByWrapperAllEq()&#123;\tQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();\tMap&lt;String,Object&gt; params = new HashMap&lt;String,Object&gt;();\tparams.put(&quot;name&quot;,&quot;小王&quot;);\tparams.put(&quot;age&quot;,25);\t//params.put(&quot;age&quot;,null);   表示在数据库中值为null\t//params.put(&quot;age&quot;,false);   表示如果值为null就忽略掉\tqueryWrapper.allEq(params);\t\tList&lt;User&gt; userList = userMapper.selectList(queryWrapper);\tuserList.forEach(System.out::println);&#125;\n\n\n\n自定义sql及分页查询自定义SQL在UserMapper.java中\npublic interfave UserMapper extends BaseMapper&lt;User&gt;&#123;\t@Select(&quot;select * from user $&#123;ew.customSqlSegment&#125;&quot;)\tList&lt;User&gt; selectAll(@Param(Constants.WRAPPER) Wrapper&lt;User&gt; wrapper);&#125;\n\n测试\n@Testpublic void selectMe()&#123;\tQueryMapper&lt;User&gt; queryMapper = new QueryMapper&lt;User&gt;();\tqueryMapper.like(&quot;name&quot;,&quot;雨&quot;);\tList&lt;User&gt; userList = userMapper.selectAll(queryMapper);\tuserList.forEach(System.out::println);\t// 打印SQL应该是 select * from user where name like &#x27;%雨%&#x27;&#125;\n\n还有一种在yml中改，太麻烦了\n分页查询\nMyBatis分页介绍\n不是物理分页，是逻辑分页或内存分页，把符合条件的数据全查出来在内存中，返回你要的那部分\n问题：超大数据情况下耗内存，速度慢\n\nMP分页插件实现物理分页\n在SpringBoot环境中新建配置类MybatisPlusConfig\n@Configuration\t\t//标识为配置类的注解public class MybatisPlusConfig&#123;\t@Bean\tpublic PaginationInterceptor paginationInterceptor()&#123;\t\treturn new PaginationInterceptor();\t&#125;&#125;\n\n测试：\n@Testpublic void selectPage()&#123;\tQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();\tqueryWrapper.ge(&quot;age&quot;,26)\tPage&lt;User&gt; page = new Page&lt;User&gt;(1,2);\t// \tPage&lt;User&gt; page = new Page&lt;User&gt;(1,2，false);  这种是不需要查总记录数\t\t/* 写法一\tIPage&lt;User&gt; iPage = userMapper.selectPage(page,queryWrapper);\tSystem.out.println(&quot;总页数&quot;+iPage.getPages());\tSystem.out.println(&quot;总记录&quot;+iPage.getTotal());\tList&lt;User&gt; userList = iPage.getRecords();\t*/\t\t// 写法2\tIPage&lt;Map&lt;String,Object&gt;&gt; iPage = userMapper.selectMapsPage(page,queryWrapper);\tuserList.forEach(System.out::println);\tIPage&lt;User&gt; iPage = userMapper.selectPage(page,queryWrapper);\tSystem.out.println(&quot;总页数&quot;+iPage.getPages());\tSystem.out.println(&quot;总记录&quot;+iPage.getTotal());\tList&lt;Map&lt;String,Object&gt;&gt; userList = iPage.getRecords();\t\t\tuserList.forEach(System.out::println);&#125;\n\n更新及删除更新方法UpdateTest.java\n@RunWith(SrpingRunner.class)@SpringBootTestpublic class UpdateTest&#123;\t@Autowired\tprivate UserMapper userMapper;\t\t@Test\tpublic void updateById()&#123;\t\tUser user = new User();\t\tuser.setId(42424224234232L);\t\tuser.setAge(11);\t\tuser.setEmail(&quot;364825466@qq.com&quot;);\t\tint rows = userMapper.updateById(user);\t\tSystem.out.println(&quot;影像记录行数&quot;+rows);\t&#125;\t\t\t@Test\tpublic void updateByWrapper()&#123;\t\tUpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;User&gt;();\t\tupdateWrapper.eq(&quot;name&quot;,&quot;小白白&quot;).eq(&quot;age&quot;,13);\t\tUser user = new User();\t\tuser.setAge(11);\t\tuser.setEmail(&quot;36411825466@qq.com&quot;);\t\tint rows = userMapper.updateById(user);\t\tSystem.out.println(&quot;影像记录行数&quot;+rows);\t&#125;\t\t\t@Test\tpublic void updateByWrapper2()&#123;\t\tUpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;User&gt;();\t\tupdateWrapper.eq(&quot;name&quot;,&quot;小李&quot;).eq(&quot;age&quot;,13).set(&quot;age&quot;,15);\t\tint rows = userMapper.updateById(user);\t\tSystem.out.println(&quot;影像记录行数&quot;+rows);\t&#125;\t\t\t@Test\tpublic void updateByWrapper2()&#123;\t\tLambdaUpdateWrapper&lt;User&gt; lambdaUpdateWrapper = Wrappers.&lt;User&gt;lanbdaUpdateWrapper&lt;User&gt;();\t\tlambdaUpdateWrapper.eq(User::getName,&quot;小李&quot;).eq(User::getAge,13).set(User::getAge,15);\t\tint rows = userMapper.updateById(null,lambdaUpdate);\t\tSystem.out.println(&quot;影像记录行数&quot;+rows);\t&#125;\t&#125;\n\n\n\n删除DeleteTest.java\n@RunWith(SrpingRunner.class)@SpringBootTestpublic class UpdateTest&#123;\t@Autowired\tprivate UserMapper userMapper;\t@Test\tpublic void deleteById()&#123;\t\tint rows = userMapper.deleteById(158937984579823L);\t\tSystem.out.println(&quot;删除条数&quot;+rows);\t&#125;\t\t@Test\tpublic void deleteByMap()&#123;\t\tMap&lt;String,Object&gt; columnMap = new HashMap&lt;&gt;();\t\tcolumnMap.put(&quot;name&quot;,&quot;向后&quot;);\t\tcolumnMap.put(&quot;age&quot;,12);\t\tint rows = userMapper.deleteByMap(columnMap);\t\tSystem.out.println(&quot;删除条数&quot;+rows);\t&#125;\t\t@Test\tpublic void deleteByIds()&#123;\t\tint rows = userMapper.deleteBatchIds(Arrays.asList(编个id,编个id,编个id));\t\tSystem.out.println(&quot;删除条数&quot;+rows);\t&#125;\t\t\t@Test\tpublic void deleteByWrapper()&#123;        LambdaQueryWrapper&lt;User&gt; lambdaQuery = Wrappers.&lt;User&gt;lambdaQuery();        lambdaQuery.eq(User::getAge,27).or().gt(User::getAge,41);        int rows = userMapper.delete(lambdaQuery);\t\tSystem.out.println(&quot;删除条数&quot;+rows);\t&#125;\t&#125;\n\n","categories":[],"tags":["SpringBoot","MyBatisPlus"]},{"title":"关于日期的动态SQL","url":"/2019/11/20/%E5%85%B3%E4%BA%8E%E6%97%A5%E6%9C%9F%E7%9A%84%E5%8A%A8%E6%80%81SQL/","content":"关于日期的动态sql\n&lt;update id=&quot;updateCheckTask&quot;&gt;        update sl_check_task        &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;            &lt;if test=&quot;checkTaskName != null and checkTaskName != &#x27;&#x27;&quot;&gt;                check_task_name=#&#123;checkTaskName&#125;,            &lt;/if&gt;            &lt;if test=&quot;checkTaskStart != null and checkTaskStart != &#x27;&#x27;&quot;&gt;                check_task_start=#&#123;checkTaskStart&#125;,            &lt;/if&gt;            &lt;if test=&quot;checkTaskEnd != null and checkTaskEnd != &#x27;&#x27;&quot;&gt;                check_task_end=#&#123;checkTaskEnd&#125;,            &lt;/if&gt;            &lt;if test=&quot;contractDate != null and contractDate != &#x27;&#x27;&quot;&gt;                contract_date=#&#123;contractDate&#125;,            &lt;/if&gt;            &lt;if test=&quot;productType != null and productType != &#x27;&#x27;&quot;&gt;                project_type=#&#123;productType&#125;,            &lt;/if&gt;            &lt;if test=&quot;decorationStandard != null and decorationStandard != &#x27;&#x27;&quot;&gt;                decoration_standard=#&#123;decorationStandard&#125;,            &lt;/if&gt;        &lt;/trim&gt;        where check_task_id=#&#123;checkTaskId&#125;    &lt;/update&gt;\n\n报异常\ninvalid comparison: java.util.Date and java.lang.String\n\n原因：\n&lt;if test=&quot;checkTaskStart != null and checkTaskStart != &#x27;&#x27;&quot;&gt;            check_task_start=#&#123;checkTaskStart&#125;,        &lt;/if&gt;        &lt;if test=&quot;checkTaskEnd != null and checkTaskEnd != &#x27;&#x27;&quot;&gt;            check_task_end=#&#123;checkTaskEnd&#125;,        &lt;/if&gt;        &lt;if test=&quot;contractDate != null and contractDate != &#x27;&#x27;&quot;&gt;            contract_date=#&#123;contractDate&#125;,        &lt;/if&gt;\n\n\n\ndate为Date类型，不能和‘’比较，只判断是不是null就行啦:\n&lt;if test=&quot;checkTaskStart != null&quot;&gt;               check_task_start=#&#123;checkTaskStart&#125;,           &lt;/if&gt;           &lt;if test=&quot;checkTaskEnd != null&quot;&gt;               check_task_end=#&#123;checkTaskEnd&#125;,           &lt;/if&gt;           &lt;if test=&quot;contractDate != null&quot;&gt;               contract_date=#&#123;contractDate&#125;,           &lt;/if&gt;\n\n\n","categories":[],"tags":["MySQL","SpringBoot"]},{"title":"编程新手如何入门","url":"/2019/11/19/%E7%BC%96%E7%A8%8B%E6%96%B0%E6%89%8B%E5%A6%82%E4%BD%95%E5%85%A5%E9%97%A8/","content":"\n\n学习编程, 既要考虑诗和远方, 也要考虑眼前的苟且。\n每年像你这样的学生不计其数，大一刚进校，一门C语言学校发一本垃圾C语言教材，按时上课，老师在那里念念PPT  ，讲讲浮点型变量，malloc啥的，你若认真听了，那你可能懂了，但是发现不会写，你若没听，玩手机了，你是既不懂，也不会写，上来上去，蒙在鼓里的人出不来，水平就一直这样，龟速增长。 \n有的学生学的一头雾水，开始怀疑自己，准备转专业，放弃计算机，有的学生学懂了，写程序一直报  错，开始怀疑自己，有的学生觉得教材写得不好，去书店转了一圈，买了三四本C语言的书，但最后厚厚的灰尘盖在了书上，再也没翻过。 \n这三种学生，如果继续这样，最后都要凉凉。 \n马克思教给我们要具体问题具体分析，那我今天就来分析一下，计算机专业的学生，到底应该怎么学计算机，才能效果最好，进步最快。 \n如果你要学习物理，我推荐你顺着物理的发展史学习，先学习牛顿经典物理，再学习热力学，电磁学这些不那么经典的，再学习相对论，量子力学这种彻底推翻经典物理的，再学习量子电动力学这种硬核的，比较前沿的，整个学习过程，是自底向上 。\n但是学习计算机，真的适合这样吗？ \n先学习电路，冯诺依曼结构，造一台计算机？然后再用汇编写个小操作系统？写个小编译器？最后一步一步往上走，最后开始用高级语言编程？ \n你要是这么学，必然爆炸。\n计算机的学习最好应该是自顶向下。\n这个顶，顶到什么程度？\n有人说，C语言就是高级语言了，从C语言开始学就好了。\n但是如果让我教计算机，我第一节课教学生们的，绝对不是C语言，而是教大家如何使用Github，Stackoverflow，告诉世界上正在发生什么，程序员之间是如何协作的，告诉你在这个大社区，你可以读到这个世界最牛逼的程序员写的代码。  \n我还要告诉大家如何使用云服务，告诉大家可以买一个一个月十块钱的学生服务器，自己做点有趣的事，我还要推荐大家去用Visual Studio Code，而不是简单粗暴的在机房装一个VC6，或者 CodeBlocks，美其名曰，“我们当年用记事本还XXXX，现在的学生被惯坏了”这种话。 \n如果可以，我还会教同学们如何科学上网，让英文编程环境成为习惯，让遇到问题google，而不是百度成为习惯，让大家在第一节课上完，就能进入这个世界编程大社区，哪怕什么都不懂，你也能保证所在的社区，就是世界程序员的大家庭当你进入Github，看着各种有趣的项目的时候，相信我，你的视野就会在此为起点，快速打开，不断增长，进入一个良性循环。   \n而当刚上大一的学生第一次进入github时候，被眼前的各种没听过，没见过，但感觉很厉害的项目所吸引的时候，当他两眼冒光的时候，我就知道，他这四年，成了。\n有人会这样说我：  “Github还用教？刚才你说的那些学生，如果能被C语言的困难打倒，那他也不适合做程序员，转行正好。”  \n像这种话，我想说，在很多时候，佛和魔仅在一念之间，你在最开始的时候点到了，给了他引导，他以后可能会马上进入一个正反馈状态，如果你没点到，马上可能就负反馈了。  \n我一直觉得国内的计算机专业的学生很可怜。\n当VScode表现越来越优异的时候，学生们还在机房用着VC6，看着密密麻麻的报错无可奈何。\n当Google搜索可以精准定位你的问题的时候，学生们还在为百度搜索出来乱七八糟的搜索结果无可奈何。\n你用百度，用中文搜索，你连stackoverflow都搜不出来。\n但是你可以去问问，做一个调查，有多少大一结束的学生，没上过stackoverflow，不知道怎么在  github里提交issue和pull request，你统计一下，看看这个比例有多大？ \n你再统计一下有多少比例的大一结束的学生没用过google，并且对其用不了的原因不太清楚？ \n视野打不开，一切都完了。 \n有人说，刚开始直接学了python这种很简单的高级语言，以后遇到C肯定被吓跑了。 \n事实恰恰相反，在你了解到python的性能问题时，你才会了解python是解释型语言，C是编程型语言，  你才会思考为什么C更快，进而，如果需要用C，去学C。 \n在你在编程语言中涉及到了“原子性”，“同步”，“异步”，“线程”，“进程”，“内存分配“  等概念的时候，你会自然而然地产生很多疑问，进而去学习操作系统， 在学操作系统的过程中，你之前的一系列疑问逐渐被解决，这个过程是很爽的。\n当你发现某个算法，人家的实现比你快很多的时候，你会自然地去思考，为什么我的程序运行这么慢，然后发现对方用的数据结构与你不同，甚至用了一些算法，比如动态规划等，这也会驱使你去学习算法，学习数据结构。  \n有了需求和疑问，再去学，这样一个过程，是学习的金钥匙。 \n你指望学生自己打开视野，但是那些自己打不开，需要你帮忙开下门的呢？ \n你指望学生自己打开视野，但是那些自己打不开，需要你帮忙开下门的呢？ \n比如你学C语言，与其去做那些OJ题，不如在github上找个C语言项目，然后阅读，理解，修改，模仿。  \n个人认为在知识爆炸的年代，两不要：\n学个啥都要买本教材，试图线性地，从头读到尾。、（真实情况：经典教材都能下载到免费pdf，语言，框架，文档往往已经写的很好，而且最新，github  上有无数优质开源学习资源） \n不读优质代码，不参考最佳实践，啥都要自己从头开始搞。 \n三个要：\n要读文档，英文文档\n做知识输出，用文字总结自己的学习内容。\n多用命令行\n我曾听过一种论调，说程序员不会用命令行也没关系。 \n我想说的是，第一，这个世界没有那么美好，什么都要给你做一个图形界面，第二，对于命令复杂，命令多的工具，就算做出来图形界面，往往比命令行更难用，而且命令行可以用命令行脚本进行批文件自动化执行。 \n两个原则：\n有问题，先文档，再stackoverflow，再技术文章\n要用实例驱动学习，不要说你会什么，要说你做了什么\n我希望所有程序员明白一个事实是，”我会什么”这句话，其实是最没用，  最虚飘飘的东西，你说你会java，python，c，rust，go，然后呢？你怎么证明？  写个hello world？会用api？ \n但是你要说，XX著名项目作者，那你就牛了，我也不需要让你证明什么了。 \n转载自知乎：@ 牛岱  \n","categories":[],"tags":["杂谈"]},{"title":"hexo命令崩溃","url":"/2019/11/18/hexo%E5%91%BD%E4%BB%A4%E5%B4%A9%E6%BA%83/","content":"在弄百度收录之后，hexo命令都不好使了\n$ hexo sINFO  Start processingFATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTypeError: Cannot read property &#x27;count&#x27; of undefined    at Hexo.module.exports (C:\\Blog\\blog\\myblog\\node_modules\\hexo-baidu-url-submit\\lib\\generator.js:4:41)    at Hexo.tryCatcher (C:\\Blog\\blog\\myblog\\node_modules\\bluebird\\js\\release\\util.js:16:23)    at Hexo.&lt;anonymous&gt; (C:\\Blog\\blog\\myblog\\node_modules\\bluebird\\js\\release\\method.js:15:34)    at Promise.map.key (C:\\Blog\\blog\\myblog\\node_modules\\hexo\\lib\\hexo\\index.js:318:20)    at tryCatcher (C:\\Blog\\blog\\myblog\\node_modules\\bluebird\\js\\release\\util.js:16:23)    at MappingPromiseArray._promiseFulfilled (C:\\Blog\\blog\\myblog\\node_modules\\bluebird\\js\\release\\map.js:61:38)    at MappingPromiseArray.PromiseArray._iterate (C:\\Blog\\blog\\myblog\\node_modules\\bluebird\\js\\release\\promise_array.js:114:31)    at MappingPromiseArray.init (C:\\Blog\\blog\\myblog\\node_modules\\bluebird\\js\\release\\promise_array.js:78:10)    at MappingPromiseArray._asyncInit (C:\\Blog\\blog\\myblog\\node_modules\\bluebird\\js\\release\\map.js:30:10)    at _drainQueueStep (C:\\Blog\\blog\\myblog\\node_modules\\bluebird\\js\\release\\async.js:142:12)    at _drainQueue (C:\\Blog\\blog\\myblog\\node_modules\\bluebird\\js\\release\\async.js:131:9)    at Async._drainQueues (C:\\Blog\\blog\\myblog\\node_modules\\bluebird\\js\\release\\async.js:147:5)    at Immediate.Async.drainQueues [as _onImmediate] (C:\\Blog\\blog\\myblog\\node_modules\\bluebird\\js\\release\\async.js:17:14)    at runCallback (timers.js:705:18)    at tryOnImmediate (timers.js:676:5)    at processImmediate (timers.js:658:5)\n\n解决方案：删除百度自动提交\nnpm remove hexo-baidu-url-submit\n\n","categories":[],"tags":["hexo"]},{"title":"MySQL根据字段查找表","url":"/2019/11/04/MySQL%E6%A0%B9%E6%8D%AE%E5%AD%97%E6%AE%B5%E6%9F%A5%E6%89%BE%E8%A1%A8/","content":"SELECT table_name from information_schema.columnswhere TABLE_SCHEMA=’DBName’ and COLUMN_NAME=’columnName’\n解释一下：\n        DBName: 要查询的数据库名称；\n\n        columnName: 你所知道的列;\n\n原文链接：https://blog.csdn.net/yyy18237592983/article/details/80320955\n","categories":[],"tags":["MySQL"]},{"title":"hexo绑定个人域名","url":"/2019/10/30/hexo%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D/","content":"前段时间用 hexo 搭建的 gitpage 个人博客，服务器用的是 github 的，然后域名默认也是 github 下的二级域名：username.github.io, 现在为了提升格调准备将自己的博客指向一个新的域名。下面记录下过程。\n\n\n购买域名国内的域名服务商有新网，腾讯云，还有阿里云等。下面以阿里云的为例：\n在阿里云购买了自己心仪的域名后，进入阿里云的管理控制台-域名与网站-域名就可以看到购买的域名此时的域名状态是未实名认证的，然后就是实名认证（一般需要2小时左右）。\n域名解析首先获取自己 github 的二级域名的 IP地址，windows 下直接在 cmd 里 Ping 一下自己的博客就会得到 IP 地址：\n下面通过 DNS域名解析将购买的域名指向 github 的二级域名：username.github.io，进入阿里云的管理控制台-域名-解析\n\n \n记录值就是自己 github 的二级域名的 IP地址。\n设置CNAME在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名。\n\n在 github 上面，打开 username.github.io 项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。\n\n好了，新域名配置完成，可以访问了。\n参考链接：https://blog.csdn.net/wgshun616/article/details/81019739\n","categories":[],"tags":["hexo"]},{"title":"SpringBoot热部署","url":"/2019/10/30/SpringBoot%E7%83%AD%E9%83%A8%E7%BD%B2/","content":"每次改完都要重新停止应用，编码过程中，显得比较麻烦。希望能够在项目中修改代码可以不用重新停止应用再重新启动，可以使用springboot中的热部署功能，这里我们使用devtools：\n\n\napplication-*.yml\nspring: thymeleaf:    cache: true  devtools:    restart:      enabled: true      additional-paths: src/main/java\n\npom.xml\n&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\t\t\t&lt;optional&gt;true&lt;/optional&gt;\t\t&lt;/dependency&gt;\n\n\n\n\n\n","categories":[],"tags":["SpringBoot"]},{"title":"idea没有springboot","url":"/2019/10/30/idea%E6%B2%A1%E6%9C%89springboot/","content":" 在settings -&gt; Plugins 里面搜索spring boot，勾选上，然后再重启下idea，就可以了。如果Plugins里面没有spring boot的话，先安装下，再勾选 \n","categories":[],"tags":["SpringBoot"]},{"title":"单例模式","url":"/2019/10/30/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"单例模式\n\n有些对象我们只需要一个，比如：\n配置文件、工具类、线程池、缓存、日志对象等\n如果创建出多个实例，就会导致许多问题，比如占用过多资源，不一致结果等\n保证应用中某个对象的实例有且仅有一个\n饿汉模式饿汉模式就是类加载的时候直接创建了实例，只要类加载了他就加载了，不管用户是否调用，因为用static直接创建了类的唯一实例\n静态初始化方式，在启动加载单例类时就实例化对象，只实例化一次，以后用到的时候就不需要再去实例化了，加载类的时候速度比较慢，但以后获得对象的速度比较快，该对象从加载到应用结束一致占用资源\n/** * 单例模式 * 应用场合：有些对象只需要一个就足够了 * 作用：保证整个应用程序中某个实例有且只有一个 * 分类：饿汉 懒汉 */public class SinglePattern &#123;    // 1.将构造方法私有化，不允许外部直接创建对象    private SinglePattern()&#123;    &#125;    // 2.创建类唯一实例 使用private static修饰    private static SinglePattern instance = new SinglePattern();    // 3.提供一个用于获取实例的方法 使用public static修饰    public static SinglePattern getInstance()&#123;        return instance;    &#125;&#125;\n\n\n\n懒汉模式懒汉模式比较懒，是你必须手动创建实例，他只是给你声明了唯一实例\n相当于一个延迟加载机制，即你需要这个对象的时候才去实例化，加载类的时候速度比较快，但以后获得对象的速度比较快，该对象在整个应用的生命周期只有一部分时间占用资源，面临多线程访问安全性问题，需要做双重锁定处理才能保证安全\n/** * 懒汉模式 */public class SinglePattern2 &#123;    // 1. 将构造方法私有化，不允许外部直接访问    private SinglePattern2()&#123;    &#125;    // 2. 声明类的唯一实例 使用private static修饰    private static SinglePattern2 instance;    // 3. 提供一个用于获取实例的方法，使用public static修饰    public static SinglePattern2 getInstance()&#123;        if (instance==null)&#123;            instance = new SinglePattern2();        &#125;        return instance;    &#125;&#125;\n\n\n\n区别\n懒汉模式：加载类时比较快，但运行时获取对象的速度比较慢，线程不安全\n饿汉模式：加载类时比较慢，但运行时获取对象的速度\n\n","categories":[],"tags":["设计模式"]},{"title":"mysql的zip安装","url":"/2019/10/22/mysql%E7%9A%84zip%E5%AE%89%E8%A3%85/","content":"1.新建my.ini[Client]port = 3306 [mysqld]#设置3306端口port = 3306# 设置mysql的安装目录basedir = C:/software/mysql-5.7.25# 设置mysql数据库的数据的存放目录datadir = C:/software/mysql-5.7.25/data# 允许最大连接数max_connections=200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB [mysql]# 设置mysql客户端默认字符集default-character-set=utf8\n\n2.初始化mysql，搜索cmd找到命令提示符，右键以管理员身份运行，进入bin目录，输入以下命令：mysqld --initialize --user=mysql --console运行后在最后会生成临时密码A temporary password is generated for root@localhost: YGds.=)8*wdh\n\n3. 输入以下命令安装mysql：mysqld --install mysql\n\n4.输入以下命令启动mysql：net start mysql\n\n5.输入以下命令登录mysql：mysql -u root -p\n\n6.修改mysql登录密码，输入以下命令（注意要输入分号）set password=password(&#x27;123456&#x27;);\n\n7.修改环境变量  path-&gt; 新建-&gt; 把bin目录粘进去","categories":[],"tags":["MySQL"]},{"title":"SpringBoot搭建Elasticsearch","url":"/2019/10/15/SpringBoot%E6%90%AD%E5%BB%BAElasticsearch/","content":"SpringBoot搭建Elasticsearch前提环境：已成功配置好Elasticsearch和Elasticsearch-head插件，并已经对Elasticsearch有一点了解\n本文档所使用各个软件版本为：\nspringboot2.1.4\njdk1.8\nelasticsearch-6.2.4\n所使用的Spring提供的封装套件：\nSpring Data Elasticsearch\n开始准备：\n\n新建一个springboot项目，默认依赖只需引入web即可\n具体操作：略\n开启Elasticsearch主程序\n具体操作，详见环境搭建\n开启Elasticsearch-head可视化客户端插件\n具体操作，详见环境搭建\n开始搭建一、依赖引入只需额外引入\n&lt;!-- elasticsearch启动器 (必须)--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 测试所需--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;   &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;\n\n二、目录结构\n三、配置文件application.propertiesspring.data.elasticsearch.cluster-name=my-applicationspring.data.elasticsearch.cluster-nodes=127.0.0.1:9300\n\n其中：spring.data.elasticsearch.cluster-name为elasticsearch主程序根目录下的conf文件夹中yml配置文件中cluster.name名称一样\n四、新建实体类：import org.springframework.data.annotation.Id;import org.springframework.data.elasticsearch.annotations.Document;import org.springframework.data.elasticsearch.annotations.Field;import org.springframework.data.elasticsearch.annotations.FieldType;/** * indexName索引名（数据库名称）, 必须为小写 * type   文档类型（表名）, 必须为小写 */@Document(indexName = &quot;item&quot;,type = &quot;item&quot;, shards = 4, replicas = 0)public class Item &#123;    /**     * @Description: @Id注解必须是springframework包下的     * org.springframework.data.annotation.Id     *@Author: https://blog.csdn.net/chen_2890     */    @Id    private int id;    @Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;)    private String title; //标题    @Field(type = FieldType.Keyword)    private String category;// 分类    @Field(type = FieldType.Keyword)    private String brand; // 品牌    @Field(type = FieldType.Double)    private Double price; // 价格    @Field(index = false, type = FieldType.Keyword)    private String images; // 图片地址    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getTitle() &#123;        return title;    &#125;    public void setTitle(String title) &#123;        this.title = title;    &#125;    public String getCategory() &#123;        return category;    &#125;    public void setCategory(String category) &#123;        this.category = category;    &#125;    public String getBrand() &#123;        return brand;    &#125;    public void setBrand(String brand) &#123;        this.brand = brand;    &#125;    public Double getPrice() &#123;        return price;    &#125;    public void setPrice(Double price) &#123;        this.price = price;    &#125;    public String getImages() &#123;        return images;    &#125;    public void setImages(String images) &#123;        this.images = images;    &#125;    public Item(int id, String title, String category, String brand, Double price, String images) &#123;        this.id = id;        this.title = title;        this.category = category;        this.brand = brand;        this.price = price;        this.images = images;    &#125;    public Item() &#123;    &#125;    @Override    public String toString() &#123;        return &quot;Item&#123;&quot; +                &quot;id=&quot; + id +                &quot;, title=&#x27;&quot; + title + &#x27;\\&#x27;&#x27; +                &quot;, category=&#x27;&quot; + category + &#x27;\\&#x27;&#x27; +                &quot;, brand=&#x27;&quot; + brand + &#x27;\\&#x27;&#x27; +                &quot;, price=&quot; + price +                &quot;, images=&#x27;&quot; + images + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n\n注意事项！！！！一定要包含空参构造方法，有参构造方法，get/set方法，不然会出现各种问题\n实体类中注解：@Document 作用在类，标记实体类为文档对象，一般有两个属性            indexName：对应索引库名称            type：对应在索引库中的类型            shards：分片数量，默认5            replicas：副本数量，默认1@Id 作用在成员变量，标记一个字段作为id主键@Field 作用在成员变量，标记为文档的字段，并指定字段映射属性：            type：字段类型，是枚举：FieldType，可以是text、long、short、date、integer、object等            text：存储数据时候，会自动分词，并生成索引            keyword：存储数据时候，不会分词建立索引Numerical：数值类型，分两类基本数据类型：long、interger、short、byte、double、float、half_float浮点数的高精度类型：scaled_float需要指定一个精度因子，比如10或100。elasticsearch会把真实值乘以这个因子后存储，取出时再还原。Date：日期类型elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省空间。index：是否索引，布尔类型，默认是truestore：是否存储，布尔类型，默认是falseanalyzer：分词器名称，这里的ik_max_word即使用ik分词器\n五、创建索引对应的接口public interface ItemRepository extends ElasticsearchRepository&lt;Item,Long&gt; &#123;&#125;\n\n注：以下所有操作均用test类测试六、索引操作/** *创建索引 */@Testpublic void createIndex() &#123;   elasticsearchTemplate.createIndex(Item.class);&#125;/** * 删除索引 */@Testpublic void deleteIndex() &#123;   elasticsearchTemplate.deleteIndex(Item.class);&#125;\n\n七、增加数据操作：@Testpublic void insert() &#123;   User user = new User(1,&quot;guo&quot;,&quot;guo&quot;,&quot;郭振江&quot;);   userService.save(user);&#125;/** * 插入多条数据 */@Testpublic void insertList() &#123;   List&lt;Item&gt; list = new ArrayList&lt;&gt;();   list.add(new Item(2, &quot;坚果手机R1&quot;, &quot; 手机&quot;, &quot;锤子&quot;, 3699.00, &quot;http://image.baidu.com/13123.jpg&quot;));   list.add(new Item(6, &quot;坚果手机R1&quot;, &quot; 手机&quot;, &quot;锤子&quot;, 3699.00, &quot;http://image.baidu.com/13123.jpg&quot;));   list.add(new Item(7, &quot;坚果手机R1&quot;, &quot; 手机&quot;, &quot;锤子&quot;, 3699.00, &quot;http://image.baidu.com/13123.jpg&quot;));   list.add(new Item(8, &quot;坚果手机R1&quot;, &quot; 手机&quot;, &quot;锤子&quot;, 3699.00, &quot;http://image.baidu.com/13123.jpg&quot;));   list.add(new Item(3, &quot;华为META10&quot;, &quot; 手机&quot;, &quot;华为&quot;, 4499.00, &quot;http://image.baidu.com/13123.jpg&quot;));   list.add(new Item(4, &quot;神州战神&quot;, &quot; 电脑&quot;, &quot;神州&quot;, 6499.00, &quot;http://image.baidu.com/13123.jpg&quot;));   list.add(new Item(5, &quot;王者荣耀满铭文满英雄号&quot;, &quot;账号&quot;, &quot;随易宝有限公司&quot;, 500.00, &quot;www.langzitan.cn&quot;));   // 接收对象集合，实现批量新增   itemRepository.saveAll(list);&#125;\n\n八、查询：/** * 查询指定索引下的全部信息 */@Testpublic void getAll()&#123;   Iterable&lt;Item&gt; list = this.itemRepository.findAll();   //按照价格升序查询   //Iterable&lt;Item&gt; list1 = this.itemRepository.findAll(Sort.by(&quot;price&quot;).ascending());   //按照价格降序查询   //Iterable&lt;Item&gt; list2 = this.itemRepository.findAll(Sort.by(&quot;price&quot;).descending());   for (Item item:list)&#123;      System.out.println(item);   &#125;&#125;\n\n九、自定义方法Spring Data 的另一个强大功能，是根据方法名称自动实现功能。\n比如：你的方法名叫做：findByTitle，那么它就知道你是根据title查询，然后自动帮你完成，无需写实现类。\n当然，方法名称要符合一定的约定：\n/** * 自定义方法例子，具体使用，请参考文档 */@Testpublic void queryByPriceBetween()&#123;   List&lt;Item&gt; list = this.itemRepository.findByPriceBetween(600.00, 5500.00);   for (Item item : list) &#123;      System.out.println(&quot;item = &quot; + item);   &#125;&#125;\n\n\n\n十、分词查找：/** * 分词查找，最大优点！！！！ */@Testpublic void testMatchQuery()&#123;   // 构建查询条件   NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();   // 添加基本分词查询   queryBuilder.withQuery(QueryBuilders.matchQuery(&quot;title&quot;, &quot;王者满铭文&quot;));   // 搜索，获取结果   Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build());   // 总条数   long total = items.getTotalElements();   System.out.println(&quot;total = &quot; + total);   for (Item item : items) &#123;      System.out.println(item);   &#125;&#125;\n\n十二、分页查找：/** * 分页查找 */@Testpublic void searchByPage()&#123;   // 构建查询条件   NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();   // 添加基本分词查询   queryBuilder.withQuery(QueryBuilders.termQuery(&quot;brand&quot;, &quot;锤子&quot;));   // 设置分页属性：   int page = 0;   int size = 2;   queryBuilder.withPageable(PageRequest.of(page,size));   // 搜索，获取结果   Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build());   // 总条数   long total = items.getTotalElements();   System.out.println(&quot;总条数 = &quot; + total);   // 总页数   System.out.println(&quot;总页数 = &quot; + items.getTotalPages());   // 当前页   System.out.println(&quot;当前页：&quot; + items.getNumber());   // 每页大小   System.out.println(&quot;每页大小：&quot; + items.getSize());   for (Item item : items) &#123;      System.out.println(item);   &#125;&#125;\n\n——————来自技术分享，张博文\n","categories":[],"tags":["es","技术分享","SpringBoot"]},{"title":"Elasticsearch-head插件使用","url":"/2019/10/15/Elasticsearch-head%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/","content":"Elasticsearch-head插件使用一、简介：ealsticsearch只是后端提供各种api，那么怎么直观的使用它呢？elasticsearch-head将是一款专门针对于elasticsearch的客户端工具，elasticsearch-head是一个基于node.js的前端工程\n\n\n二、配置及打开方式：略，详情请见环境配置文档\n打开方式：\n1、进入elasticsearch-head的文件夹，如：D:\\xwj_github\\elasticsearch-head\n　　2、执行 npm install\n　　3、执行 npm run start\n三、基本使用：1.集群健康值：\n　　 　\n用于观测集群的状况\n　绿色，最健康的状态，代表所有的分片包括备份都可用\n​    黄色，基本的分片可用，但是备份不可用（也可能是没有备份）\n　红色，部分的分片可用，表明分片有一部分损坏。此时执行查询部分数据仍然可以查到，遇到这种情况，还是赶快解决比较好\n​     灰色，未连接到elasticsearch服务\n\n2.索引：可以查看索引信息，以及对索引进行管理\n\n3.集群及分片：\n用于所有索引各个分片在集群中的分布情况\nnode-1就是集群的名字\n4.!1569306004691](img/1569306004691.png)\n4.索引详细信息\n可以看到索引中数据数量及所占空间的大小\n5.数据浏览可以非常直观的查看全部数据，左侧可以添加查询条件\n6.简单查询可以做简单查询，并能自动生成原生的查询语句\n7.复杂查询：　在这个页签，可以使用json进行复杂的查询，也可发送put请求新增及跟新索引，使用delete请求删除索引等等。如图所示：\n\n——————来自技术分享，张博文\n","categories":[],"tags":["es","技术分享"]},{"title":"Elasticsearch环境搭建","url":"/2019/10/15/Elasticsearch%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"Elasticsearch简介与环境搭建\n\n一、简介ElasticSearch是一个分布式，高性能、高可用、可伸缩的搜索和分析系统，\n根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。\n1、什么是搜索​        百度、Google：我们想寻找一个我们喜欢的电影或者书籍就会去百度或者Google搜索一下。​        互联网搜索：电商搜索商品，招聘网站搜索简历或者岗位​        IT系统的搜索：员工管理搜索，会议管理搜索\n2.如果用数据库做搜索会怎么样\n3.正常的sql搜索存在的问题：\n如果表记录上千万上亿了这个性能问题，另外一个如果有一个本文字段要在里面模糊配置，这个就会出现严重的性能问题\n还不能将搜索词拆分开来，比如上面这个只能搜索名字是“张三”开头的员工，如果想搜出“张小三”那是搜索不出来的。总体来说，用数据库来实现搜索，是不太靠谱的，通常性能也会很差\n\n3、什么是全文检索、倒排索引和Lucene举个简单的例子：比如最近上映的热剧（碟中谍6:全面瓦解），我们想搜索一下全面瓦解这个电视剧，可是在输入的过程，不小心输入了”全瓦解”，我们看看百度这个返回了什么，百度返回的结果确实是我想要找到的内容\n\n全文检索就比较好理解的，就是当我们输入“全瓦解”,会被拆分成”全”，“瓦解”2个此，用2个词去倒排索引里面去检索数据，检索到的数据返回。整个过程就叫做全文检索\n倒排索引\n如果这个用数据库的思维来做的话，假如一共100W的记录，按照之前的思路就是扫描100W次，而且每次扫描，都需要匹配那个文本所有的字符，确认是否包含搜索的关键词，而且还不能将搜索词拆解来进行检索如果是利用倒排索引的话，假设还是100W，拆分出来的词语，假设有1000W个词语，那么在倒排索引中，就有1000W行。我们可能不需要检索1000W词，有可能检索1次，就能找到我们需要的数据，也有可能是100W次，也有可能是1000W次这就是为什么我们命名搜索的是全瓦解，事实上只是按照瓦解搜索的，因为全在倒排索引中没有存在\n4、ElasticSearch的应用场景\n维基百科\nThe Guardian（国外新闻网站）\nStack Overflow（国外的程序异常讨论论坛）\nGitHub（开源代码管理）\n电商网站\n日志数据分析\n商品价格监控网站\nBI系统\n站内搜索\n\n5.ElasticSearch的功能分布式的搜索引擎和数据分析引擎搜索：网站的站内搜索，IT系统的检索数据分析：电商网站，统计销售排名前10的商家全文检索，结构化检索，数据分析全文检索：我想搜索商品名称包含某个关键字的商品结构化检索：我想搜索商品分类为日化用品的商品都有哪些数据分析：我们分析每一个商品分类下有多少个商品对海量数据进行近实时的处理分布式：ES自动可以将海量数据分散到多台服务器上去存储和检索海联数据的处理：分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了近实时：检索数据要花费1小时（这就不要近实时，离线批处理，batch-processing）；在秒级别对数据进行搜索和分析\n二、环境搭建1.安装Elasticsearch主文件​        （1）Elasticsearch无需安装，解压即用。\n\n​        \n​        （2）进入elasticsearch/bin目录，可以看到下面的执行文件：双击运行，等全部加载完\n\n​        \n可以看到绑定了两个端口:\n\n9300：Java程序访问的端口\n9200：浏览器、postman访问的端口\n\n（3）我们在浏览器中访问：[http://127.0.0.1:9200![](./Elasticsearch环境搭建/1569050207778.png)\n看到了上面的信息，说明你的Elasticsearch已经安装成功了\n(4)配置\nhttp.cors.enabled: true http.cors.allow-origin: &quot;*&quot;node.master: truenode.data: true\n\n然后去掉network.host: 192.168.0.1的注释并改为network.host: 0.0.0.0，\n去掉cluster.name；node.name；http.port的注释（也就是去掉#）\n第二步：关掉之前的命令提示符双击bin路径下的elasticsearch.bat重启Elasticsearch\n正常启动并且可以通过http://127.0.0.1:9200访问即配置成功\n2.配置Elasticsearch的客户端工具（1）安装node.js\n\n安装完成用cmd进入安装目录执行 node -v可查看版本号\n..\n执行 npm install -g grunt-cli 安装grunt ，安装完成后执行grunt -version查看是否安装成功，会显示安装的版本号\n\n（2）解压安装包：\n\n（3）修改Gruntfile.js\n\n（4）在对应的位置加上hostname:’*’、\n（5）在命令提示符进入该文件夹根目录例：D:\\environment\\elasticsearch-head-master \n执行npm install \n\n（6）\n执行npm run start 运行head插件，如果运行不成功建议重新安装grunt\n\n（7）打开浏览器访问：http://127.0.0.1:9100健康值为绿色即成功\n\n3 .安装Ik分词器ElasticSearch 默认采用的分词器， 是单个字分词 ，效果很差 ，所以我们需要安装一个更实用的分词器，这里采用IK分词器    \n（1）解压到Elasticsearch主文件下plugins下的一个新建文件夹，我们起名为ik\n例：解压到D:\\elasticsearch-6.2.4\\plugins\\ik\n\n（2）重启elasticsearch主文件和客户端工具\n\n正常能通过\nhttp://127.0.0.1:9200/访问\n且\nhttp://127.0.0.1:9100/健康值仍为绿色，成功\n——————来自技术分享，张博文\n","categories":[],"tags":["es","技术分享"]},{"title":"MongoDB配置","url":"/2019/10/15/MongoDB%E9%85%8D%E7%BD%AE/","content":"MongoDB安装及配置\n\nmongo安装\n\n\n\n\n\n\n\n\n\nmongo配置1.将mongodb的bin目录配置到环境变量中进入cmd命令行，输入mongod --help测试是否成功，如果输出一串相关命令提示信息，表示成功d:\\mongoDB\\bin&gt;D:\\mongoDB\\bin\\mongod.exe --config D:\\mongoDB\\mongo.config --install2.安装完毕之后，data目录即为数据库（db）目录，log目录即为日志目录，网上很多教程中，会新建db与log目录，不需要再做3..浏览器中输入http://localhost:27017/ 页面输出It looks like you are trying to access MongoDB over HTTP on the native driver port.4.常用命令net start MongoDB开启服务 net stop MongoDB关闭服务5.mongo shell命令行（管理员）中输入mongoshow dbs 显示当前所有的数据库use dbname  切换数据库db 显示当前使用的数据库show collections 显示数据库中所有的集合db.&lt;collection&gt;.insert(doc)网数据库插入文档db.students.insert(&#123;id:&quot;001&quot;,name:&quot;Lily&quot;&#125;)db.students.find() 查询当前集合中所有的文档d:\\mongoDB\\bin&gt;D:\\mongoDB\\bin\\mongod.exe --config D:\\mongoDB\\mongo.config --installd:\\mongoDB\\bin&gt;D:\\mongoDB\\bin\\mongod.exe --dbpath D:\\mongoDB\\data\\db\n\n\n\n正常执行步骤第一步\n​    创建几个文件夹具体如下：在根目录的data文件夹下创建数据库路径（db目录）、日志路径（log目录）\n第二步：配置环境变量\n在cmd中方便访问mongo\n 因为每次我们启动MongoDB服务的时候\n都需要在cmd中切换到MongoDB所在路径，然后执行 net start mongodb 命令来开启服务。\n为了解决这个问题我们可以将MongoDB配置到系统环境变量中。 \n下次在开机的时候可以直接打开cmd或者以管理员身份打开输入 net start mongodb 命令，无需切换到MongoDB所在路径进行启动。\n\n\n\n第三步\n安装路径下创建配置文件mongo.config，文件内容如下：\n\n#数据库路径dbpath = D:\\MongoDB\\data#日志输出文件路径logpath = D:\\MongoDB\\log\\mongodb.log#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件logappend = true#启用日志文件，默认启用journal = true#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falsequiet = true#端口号 默认为27017port = 27017\ndbpath=D:\\mongodb\\data\\dblogpath=D:\\mongodb\\data\\log\\mongodb.loglogappend=truejournal=truequiet=trueport=27017\n\n第四步\n打开cmd进入bin目录（管理员模式开启，为了避免错误发生）\ncd /d d:\\mongoDB\\bin\nmongod -dbpath D:\\mongodb\\data\\db\nmongodb默认连接端口27017，如果出现如图的情况，在浏览器访问：http://localhost:27017\n成功之后关闭此命令行，即关闭mongodb服务\n\n\n第五步\n在bin目录下执行\nmongod -dbpath “C:\\mongodb\\data\\db” -logpath “C:\\mongodb\\data\\log\\mongodb.log” -install -        serviceName “MongoDB”\n（把db的路径和log的路径装配到MongoDB Service服务中）\n第六步\n在bin目录下执行\nmongod –config “C:\\mongodb\\mongo.config” –install –serviceName “MongoDB”\n（把配置文件装配到MongoDB Service服务中）\n第七步：连接\n执行 net start mongodb\n错误如果命令出现重名现象，即自动生成了响应时间戳的log文件\n则通过  sc delete MongoDB\n删除服务并删除所有log文件，然后重新从第五步执行一遍\n错误 5发生系统错误 5 \n拒绝访问\n 是因为没有使用管理员模式打开cmd\n错误 1058出现1058 错误 是因为配置文件出错，如遇到1058错误\n\n删除服务 sc delete MongoDB\n检查配置文件，是否有多余的空格，空白，路径是否正确，单词拼写是否正确，然后保存\n重新执行以上步骤，将相应的文件配置到mongodb服务中\n\n其它错误同样重新配置服务，因为有时候服务默认配置路径错误，要删除后再配置，具体路径可以右键计算机，选择管理，点击服务，找到mongodb右键属性即可。安装的所有错误基本都是路径错误，按照本机情况重新检查一遍即可。\n重新配置的具体操作界面如下：\n连接在bin目录下执行 net start mongodb（cd /d d:\\mongoDB\\bin）\n连接成功后执行mongo\n执行help查看命令\n创建数据库以下实例我们创建了数据库 runoob:\n&gt; use runoobswitched to db runoob&gt; dbrunoob&gt; \n\n如果你想查看所有数据库，可以使用 show dbs 命令：\n&gt; show dbsadmin   0.000GBconfig  0.000GBlocal   0.000GB&gt; \n\n可以看到，我们刚创建的数据库 runoob 并不在数据库的列表中， 要显示它，我们需要向 runoob 数据库插入一些数据。\n&gt; db.runoob.insert(&#123;&quot;name&quot;:&quot;小明&quot;&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; show dbs\tadmin   0.000GBconfig  0.000GBlocal   0.000GBrunoob  0.000GB\n\nMongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。\nMongoDB 删除数据库MongoDB 删除数据库的语法格式如下：\ndb.dropDatabase()\n\n删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。\n首先，查看所有数据库：\n&gt; show dbsadmin   0.000GBconfig  0.000GBlocal   0.000GBrunoob  0.000GB\n\n接下来我们切换到数据库 runoob：\n&gt; use runoobswitched to db runoob&gt; \n\n执行删除命令：\n&gt; db.dropDatabase()&#123; &quot;dropped&quot; : &quot;runoob&quot;, &quot;ok&quot; : 1 &#125;\n\n最后，我们再通过 show dbs 命令数据库是否删除成功：\n&gt; show dbsadmin   0.000GBconfig  0.000GBlocal   0.000GB\n\n以下实例删除了 runoob 数据库中的集合 site：\n&gt; use runoobswitched to db runoob&gt; db.createCollection(&quot;runoob&quot;)     # 先创建集合，类似数据库中的表&gt; show tablesrunoob&gt; db.runoob.drop()true&gt; show tables&gt; \n\n在 test 数据库中创建 runoob 集合：\n&gt; use testswitched to db test&gt; db.createCollection(&quot;runoob&quot;)&#123; &quot;ok&quot; : 1 &#125;&gt;\n\n如果要查看已有集合，可以使用 show collections 或 show tables 命令：\n&gt; show collectionsrunoobsystem.indexes\n\n下面是带有几个关键参数的 createCollection() 的用法：（了解）\n创建固定集合 mycol，整个集合空间大小 6142800 KB, 文档最大个数为 10000 个。\n&gt; db.createCollection(&quot;mycol&quot;, &#123; capped : true, autoIndexId : true, size :    6142800, max : 10000 &#125; )&#123; &quot;ok&quot; : 1 &#125;&gt;\n\n在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。\n&gt; db.mycol2.insert(&#123;&quot;name&quot; : &quot;小明&quot;&#125;)&gt; show collectionsmycol2...\n\n删除集合在数据库 mydb 中，我们可以先通过 show collections 命令查看已存在的集合：\n&gt;use mydbswitched to db mydb&gt;show collectionsmycolmycol2system.indexesrunoob&gt;\n\n接着删除集合 mycol2 :\n&gt;db.mycol2.drop()true&gt;\n\n通过 show collections 再次查看数据库 mydb 中的集合：\n&gt;show collectionsmycolsystem.indexesrunoob&gt;\n\n从结果中可以看出 mycol2 集合已被删除。\nIDEA连接mongodb（查询和插入）import com.mongodb.*;import com.mongodb.client.FindIterable;import com.mongodb.client.MongoCollection;import com.mongodb.client.MongoCursor;import com.mongodb.client.MongoDatabase;import org.bson.Document;import java.util.ArrayList;import java.util.List;public class mongoConnectionTest &#123;    public static void main(String[] args) &#123;        //这里的 &quot;localhost&quot; 表示连接的服务器地址，27017 为端口号。        // 可以省略 端口号 不写，系统将默认端口号为 27017        //MongoClient mongoClient = new MongoClient(&quot;localhost&quot;);        MongoClient mongoClient = new MongoClient(&quot;127.0.0.1&quot;);        //连接到数据库： &quot;test&quot; 表示数据库名        // 若指定的数据库不存在，mongoDB将会在你第一次插入文档时创建数据库。        MongoDatabase mongoDatabase = mongoClient.getDatabase(&quot;test&quot;);        //获取集合        MongoCollection&lt;Document&gt; collection = mongoDatabase.getCollection(&quot;test&quot;);        /*        mongoDatabase.createCollection(&quot;javatest&quot;);        System.out.println(&quot;集合创建成功&quot;);        Document document = new Document(&quot;title&quot;, &quot;MongoDB&quot;).                append(&quot;description&quot;, &quot;database&quot;).                append(&quot;likes&quot;, 100).                append(&quot;by&quot;, &quot;Fly&quot;);        List&lt;Document&gt; documents = new ArrayList&lt;Document&gt;();        documents.add(document);        collection.insertMany(documents);        System.out.println(&quot;文档插入成功&quot;);        */            //查找集合中的所有文档        FindIterable findIterable = collection.find();        MongoCursor cursor = findIterable.iterator();        //输出数据        while(cursor.hasNext())&#123;            System.out.println(cursor.next());        &#125;        mongoClient.close();    &#125;&#125;\n\n——————来自技术分享，刘雨竹\n","categories":[],"tags":["技术分享","MongoDB"]},{"title":"MongoDB实现评论","url":"/2019/10/15/MongoDB%E5%AE%9E%E7%8E%B0%E8%AF%84%E8%AE%BA/","content":"mongodb评论功能实现\n\n一、mongodb 的优势与劣势特点：\nMongoDB目前3大核心优势：『灵活模式』+ 『高可用性』 + 『可扩展性』，通过json文档来实现灵活模式，通过复制集来保证高可用，通过Sharded cluster来保证可扩展性。\n应用场景：\n\n业务需要事务，使用mysql，因为mongodb不支持事务\n数据量大，但是数据本身价值不大，使用mongodbps：加载大量低价值的业务数据\n数据是非结构化的，且数据量大，使用mongodb\n业务未来走向不明确，使用mongodb，方便扩展\n\n优势：\n\n不存在SQL注入\n不需要提前创建表，可以直接写入数据\n字段数据格式自由 比如mysql中id 字段是数字，输入字符串会出错，mongodb不会\n可以处理json结构，并对其进行处理比如 字段a的值为{“a”:11,”b”:12,”c”:”abc”,”d”:[1,2,3]}你可以直接去读取或设置a字段的b值 a.b，读取a字段d数组的第二个值：a.d.1,可以去删除a字段的a数据$unset:{“a.a”:1},就会变成：{“b”:12,”c”:”abc”,”d”:[1,2,3]}\n可以使用upsert操作，修改的数据不存在的时候直接插入该数据\n查询和插入效率在没有索引的情况下远大于mysql\n\n缺点：\n\nmongodb是nosql数据库，关系能力薄弱，不能使用join，union来联合查找\n事务能力薄弱\n效率存在波动性，不是很稳定\n\nMongoDB可以将模式设计划分为内嵌模式和 引用模式\n内嵌模式简单来讲，内嵌模式就是将关联数据，放在一个文档中。例如以下员工信息采用内嵌模式了而存储在了一个文档中：\n\n根据上面的描述可以看出，内嵌模型可以给应用程序提供很好的数据查询性能，因为基于内嵌模型，可以通过一次数据库操作得到所有相关的数据。同时，内嵌模型可以使数据更新操作变成一个原子写操作。然而，内嵌模型也可能引入一些问题，比如说文档会越来越大，这样就可能会影响数据库写操作的性能，还可能会产生数据碎片\n我们下面的demo就采用内嵌模型实现。\n引用模式引用模式是将数据存储在不同集合的文档中，而通过关系数据进行关联。例如，这里采用引用模式将员工信息存储在了3个文档中，基本信息一个文档，联系方式一个文档，登录权限放在了一个文档中。每个文档之前通过user_id来关联。\n\n使用内嵌模型往往会带来数据的冗余，却可以提升数据查询的效率。但是，当应用程序基本上不通过内嵌模型查询，或者说查询效率的提升不足以弥补数据冗余带来的问题时，我们就应该考虑引用模型了。 \n二、评论实现1.数据库设计（1）自由模式，无需提前声明、创建表结构，即不用先创建表、添加字段，然后才可以Insert数据。默认情况下MongoDB无需这样操作。\n（2）键值类型自由，MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。字段值可以包含其他文档，数组及文档数组。\n按照业务来慢慢添加，整个集合的存储文档格式就可以形成了。\n一般现在最常见的和最实用的都是二级评论，所以这里用二级评论举例\n一级评论， 文章id，用户id，用户评论内容，用户评论时间，评论回复\n其中回复即二级评论，\n包括 评论者id，评论者昵称，评论者评论内容，评论时间\n\n这里就遇到一个问题，二级评论可不可以被评论，如果不可以，显然不合理。\n所以这里仿照微博，在遇到二级评论的评论时，通过@确定回复的用户，内容全部和二级评论在同一级显示。\n因此我们设计出这样一个数据结构（此时二级评论和二级评论的回复是不同级的）\n&#123;    &quot;_id&quot; : ObjectId(&quot;597aa23add840cd4ce0681d1&quot;),    &quot;comment_blog_id&quot; : &quot;ObjectId(&quot;597aa23add840213432rdsfsed1&quot;)&quot;,    &quot;comment_user_id&quot; : &quot;100001&quot;,    &quot;comment_user_name&quot;: &quot;刘德宝&quot;,    &quot;comment_user_img&quot;: &quot;图片地址&quot;,    &quot;comment_content&quot; : &quot;1号用户的评论&quot;,    &quot;create_time&quot; : &quot;2017-15-12 14:00&quot;,    &quot;comment_responses&quot; : [         &#123;        &quot;_id&quot; : ObjectId(&quot;597aa23add840cd4ce0681d1&quot;),            &quot;response_user_id&quot; : &quot;1000002&quot;,            &quot;response_user_name&quot; : &quot;朱秀秀&quot;,            &quot;response_user_img&quot; : &quot;图片地址&quot;,            &quot;response_content&quot; : [                 &quot;这是2号用户给刘德宝的评论&quot;,             ],            &quot;create_time&quot; : &quot;2017-15-12 14:00&quot;,        &#125;,         &#123;            &quot;response_user_id&quot; : &quot;1000005&quot;,            &quot;response_user_name&quot; : &quot;小火龙&quot;,            &quot;response_user_img&quot; : &quot;图片地址&quot;,            &quot;response_content&quot; : [                  &quot;这是5号用户给刘德宝的回复&quot;,             ],            &quot;create_time&quot; : &quot;2017-15-12 14:00&quot;,            ]        &#125;    ]&#125;\n\n其中的评论和回复的id，昵称，和头像是方便查询显示使用，并且id可以用来做消息推送\n\n\n评论全部不存在。\n一级评论未存在，全空，最下方有一级评论回复框，可以进行评论产生comment\n\n一级评论存在，没有回复，点击回复，出现回复框，完成回复，即二级评论，可以回复，产生comment.response\n同理对二级评论的回复也是通过点击生成回复框，然后进行回复。然后判断是否是回复的一级评论来控制是否显示回复两个字即可。\n所以和二级评论实现是同一个逻辑，前台即可完成。\n2.spring整合mongodb整合部分最难的就是配置和熟悉对mongodb数据库的操作，其他的前台传参和逻辑编写大家都很熟悉。这里主要介绍一下mongodb操作的坑\nmongoRepository和mongoTemplate①、Spring Data MongoDB 是 Spring 框架访问 MongoDB 数据库的分支，使用它可以非常方便地操作 MongoDB 数据库。\nSpring Data MongoDB 是 Spring Source 的一个子项目，旨在为关系型数据库、非关系型数据、Map-Reduce框架、云数据服务等等提供统一的数据访问API。\nSpring Data 提供了基于Repository的统一接口 MongoRepository 完成对象的 CRUD 操作以及查询方法、排序和分页方法等。\n使用 Spring Data 可以帮助我们快速构建项目，非常方便，Spring Data 在数据持久层已经写好了常用功能，我们只需要定义一个接口去继承 Spring Data 提供的接口，就可以实现对数据库的操作，也可以自定义接口方法，甚至这些自定义方法都不需要我们手动去实现，Reposity 会自动完成实现。\n实现方法：\n1.创建自定义接口 xxxRepository ，继承 MongoRepository，这样xxxRepository 就直接拥有了MongoRepository 中定义好的基本CRUD操作，同时可以完成方法扩展，只需要在xxxRepository 中按照规则声明抽象方法即可，MongoRepository 会自动完成方法实现，同时在类定义处添加@Repository 注解完成IoC注入。\n2.创建自定义接口 xxxService 以及实现类xxxServiceImpl，并通过自动装载将xxxRepository 注入xxxServiceImpl。\n3.创建 xxxController 实现相关业务方法。\nspring-data-mongodb其实有两种实现方式，一种是直接继承MongoRepository接口，dao层的实现，默认提供了CRUD的各种方法，几乎不用编写任何代码。另一种是通过MongoTemplate来操作数据库，这样需要自定义dao层接口，默认没有任何接口可以使用\nCriteria类：它封装所有的语句，以方法的形式进行查询。\nQuery类：这是将语句进行封装或者添加排序之类的操作。（实现分页操作就在这里）\nmongoTemplate操作简介1.添加依赖\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt;  &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n添加spring和mongodb的依赖\n网上都说要加一个mongo的依赖类似于这种\n\n            org.mongodb\n            mongo-java-driver\n            2.13.0\n        \n\n\n\n2.mongodb配置文件\nmongodb.properties\n#数据库名称mongo.dbname=sag#用户名mongo.username=#密码mongo.password=#主机mongo.host=127.0.0.1#端口mongo.port=27017#线程最大阻塞数mongo.connectionsPerHost=8#线程队列数mongo.threadsAllowedToBlockForConnectionMultiplier=4#连接超时时间，单位毫秒mongo.connectTimeout=1500#最大等待时间mongo.maxWaitTime=1500#自动连接mongo.autoConnectRetry=true#socket存活mongo.socketKeepAlive=true#socket超时时间mongo.socketTimeout=1500#读写分离mongo.slaveOk=true\n\n\n\nspring-mongodb.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mongo=&quot;http://www.springframework.org/schema/data/mongo&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/data/mongo http://www.springframework.org/schema/data/mongo/spring-mongo.xsd&quot;&gt;   &lt;!--引入MongoDB连接文件--&gt;  &lt;context:property-placeholder location=&quot;classpath:mongodb.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt;   &lt;!--连接MongoDB服务器--&gt;   &lt;!-- 除此之外还有一个mongo连接，标签为&lt;mongo-mongo&gt; 版本较低时使用 --&gt;   &lt;mongo:mongo-client id=&quot;mongo&quot; host=&quot;$&#123;mongo.host&#125;&quot; port=&quot;$&#123;mongo.port&#125;&quot; &gt;&lt;mongo:client-options               connections-per-host=&quot;$&#123;mongo.connectionsPerHost&#125;&quot;threads-allowed-to-block-for-connection-multiplier=&quot;$&#123;mongo.threadsAllowedToBlockForConnectionMultiplier&#125;&quot;connect-timeout=&quot;$&#123;mongo.connectTimeout&#125;&quot;max-wait-time=&quot;$&#123;mongo.maxWaitTime&#125;&quot;socket-keep-alive=&quot;$&#123;mongo.socketKeepAlive&#125;&quot;socket-timeout=&quot;$&#123;mongo.socketTimeout&#125;&quot;/&gt; &lt;/mongo:mongo-client&gt;  &lt;bean id=&quot;mappingContext&quot;          \t\t\t     class=&quot;org.springframework.data.mongodb.core.mapping.MongoMappingContext&quot; /&gt; &lt;!-- 去掉默认的_class属性 --&gt;  &lt;bean id=&quot;customMongoTypeMapper&quot;          class=&quot;org.springframework.data.mongodb.core.convert.DefaultMongoTypeMapper&quot;&gt;        &lt;constructor-arg name=&quot;typeKey&quot;&gt;&lt;null/&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;   &lt;bean id=&quot;mappingMongoConverter&quot; class=&quot;org.springframework.data.mongodb.core.convert.MappingMongoConverter&quot;&gt;&lt;constructor-arg name=&quot;mongoDbFactory&quot; ref=&quot;mongoDbFactory&quot; /&gt;       &lt;constructor-arg name=&quot;mappingContext&quot; ref=&quot;mappingContext&quot; /&gt;    &lt;property name=&quot;typeMapper&quot; ref=&quot;customMongoTypeMapper&quot; /&gt;&lt;/bean&gt;    &lt;!-- mongo的工厂，通过它来取得mongo实例,dbname为mongodb的数据库名，没有的话会自动创建 --&gt;&lt;mongo:db-factory id=&quot;mongoDbFactory&quot;  dbname=&quot;$&#123;mongo.dbname&#125;&quot; mongo-ref=&quot;mongo&quot;/&gt; &lt;!-- 配置mongoTemplate --&gt;&lt;!-- mongodb的主要操作对象，所有对mongodb的增删改查的操作都是通过它完成--&gt;   &lt;bean id=&quot;mongoTemplate&quot; class=&quot;org.springframework.data.mongodb.core.MongoTemplate&quot;&gt;     &lt;constructor-arg name=&quot;mongoDbFactory&quot; ref=&quot;mongoDbFactory&quot;/&gt;&lt;constructor-arg name=&quot;mongoConverter&quot; ref=&quot;customMongoTypeMapper&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n\n\n在Spring框架中，对mongodb进行操作的是mongoTemplate对象。\nMongoTemplate是数据库和代码之间的接口，对数据库的操作都在它里面。\n注：MongoTemplate是线程安全的。\n在实现评论demo之前，我们先插入两个例子，感受一下mongotemplate\n这里我建了一个POJO, comment\n@Document(collection = &quot;commenttest&quot;)public class Comment &#123;  \t//@id    private String comment_id;         //评论id    private String comment_blog_id;    //文章id    private String comment_user_id;    //评论用户id    private String comment_user_name;   //评论用户名    private String comment_user_img;   //评论用户头像    private String comment_content;    //评论内容    private String comment_create_time;   //评论时间    private String comment_responses;   //评论回复&#125;\n\n\n\n然后相应的创建了一个CommentTestRepository类\n@Repository@Document(collection = &quot;commenttest&quot;)public class CommentTestRepository &#123;        @Autowired       MongoTemplate mongoTemplate;      public CommentTestRepository() &#123;            ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring/spring-mongodb.xml&quot;);                mongoTemplate = (MongoTemplate) ac.getBean(&quot;mongoTemplate&quot;);        &#125;        public void insertComment(Comment comment) &#123;               List&lt;Comment&gt; list = new ArrayList&lt;Comment&gt;();            list.add(comment);              mongoTemplate.insert(list,Comment.class);   &#125;\n\nhttp 通过 controller 进来的 mongotemplate 对象才会注入 spring ，才能正常使用，如果是通过其他 controller 类来调用同层的 controller 里面的 mongotemplate ，则该对象是 null 值，不可使用 ！而从 controller 调用 service 这种不同层的，则可以正常使用！\n\n插入成功后，可以看到两个字段与我们预期的不太一样，_ id和_ class \n_id:是系统自动生成的12字节唯一标识。满足分布式\nmongodb采用了一个称之为ObjectId的类型来做主键。ObjectId是一个12字节的 BSON 类型字符串。按照字节顺序，一次代表：\n4字节：UNIX时间戳3字节：表示运行MongoDB的机器2字节：表示生成此_id的进程3字节：由一个随机数开始的计数器生成的值 \nhttps://blog.csdn.net/xiamizy/article/details/41521025\n不使用ObjectId方法：\n\n只需要把POJO实体类里的comment_id改名为id即可完成一种类似于覆盖的效果，达到了不使用objectId的目的。\n或者在想要标识为id的属性上加上注解@id\n_class：这个字段就是用来映射Pojo的，更具体的说，是为了方便处理Pojo中存在继承的情况，增加系统的扩展性的。去掉的方法就是配置Converter，默认映射为null\n\n（\n假如到时候设计不好，字段不确定怎么办。\n个人建议是刚开始少一点，后面可以再加。\n​        映射的时候，pojo里有的属性，数据库里没有，依然可以映射\n​        数据库里有的字段，而pojo里没有对应的属性接受的话就无法完成映射了，\n​        比如我用户头像刚开始没加，只需要在对应的pojo类里，插入和查询逻辑里添加用户头像的属性和逻辑，就可以完成拓展，并不用像传统数据库再创建一个列，或者费心思再去创建几个冗余列。这就体现了mongodb的高拓展性。\n）\n\n\n评论要点：\n内嵌对象，比如comment对象里有一个response对象。那么mongotemplate映射到mongodb里的时候，对这个是怎么操作的呢。\n根据实际情况，一级评论完毕，回复是在一级评论之后才有的操作，这个之前，一级评论文档中是没有任何回复的。所以这里检查了一下comment里如果没有这个键，或者这个键为空，可不可以插入到mongodb中。答案是可以的。\n在测试的时候，尝试了两种方案。\n1.在设置comment实例的时候，把对象设置为null\ncomment.setComment_responses(null);\n\n2.不设置该属性，直接插入\n结论：两者都不会插入该属性对应的数据。也不会存在这个属性对应的键值。不会自动映射进去\n到时候要往comment里插入回复的时候，直接使用mongotemplate.upsert语句就可以完成。\n如果查到一级评论没有任何回复，它就会创建response这个键，然后插入第一条记录\n如果一级评论已经有回复，它就会插入到这个键里，成为这个键下的一个文档。\n\nmongoTemplate实现评论通过手写插入一些假数据之后，我们开始查询，插入要和实际业务逻辑相对应，这里demo就不做了，大体思路是一级评论直接插入，二级评论，前台传入一级评论的id然后根据id插入，同时记录用户名和用户头像。\n如果有，则前台显示有回复样式，没有的话，就是默认回复一级评论的二级评论。\n查询实现\nList&lt;Comment&gt; comments = mongoTemplate.find(query,Comment.class);List&lt;JSONObject&gt; comments = mongoTemplate.find(query,JSONObject.class,&quot;testMax2&quot;);       \n\nquery：查询条件，\n.class：需要查询的类型\n最后的字符串是需要查询的Collection，\n采用后面这个语句会遍历的把整个Collection查询出来，包括其下面的responses\n也可以不写，默认的是.class上注解的，但是这里采用了JSONObject.class这个类进行查询，我并没有对这个类进行注解，所以后面这个集合要写。\n整合springboot配置\n在spring官网添加mongodb即可。\n\n先入为主的导入了Mybatis但没有引入Mysql，所以这里要引入\n&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;\n\n其余的配置文件在打包上传的包里。\n总结：\n1.为什么评论要使用mongodb而不是mysql？\n​    mongodb舍弃了事务管理，但是mongodb的功能是海量数据的查询很快，读写效率高，一般用于简单的sql查询或日志类数据的写入操作。\n​    在评论的业务中，最多的就是查询评论和发表评论了。\n​    BSON文档结构的存储形式，查询很方便，不需要关联查询。\n​    其次，评论这种数据价值并不是特别大，但是量却很大，所以可以交给mongodb来存储\n​    在这种不需要事务管理，也不需要关联查询的情况下，使用mongodb可以得到更快的响应速度，更快捷的开发，更少的数据库设计。\n2.为什么使用了内嵌模型而不是引用模型？\n一对很少  one-to-few  可以采用内嵌文档\n优点：不需要单独执行一条语句去获取内嵌的内容\n缺点：无法把这些内嵌文档当做单独的实体去访问\n适用场合：一对很少且不需要单独访问内嵌内容\n——————来自技术分享，施爱港\n","categories":[],"tags":["技术分享","MongoDB"]},{"title":"单点登录","url":"/2019/10/15/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/","content":"单点登录需求背景​        在企业发展初期，企业使用的系统很少，通常一个或者两个，每个系统都有自己的登录模块，运营人员每天用自己的账号登录，很方便。但随着企业的发展，用到的系统随之增多，运营人员在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，如果10个系统需要登录分别登录十次，非常繁琐，如果不使用了，还需要分别在十个系统中依次的注销。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。\n\n\n传统单系统模式下的登录原理​        浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联：\n\n​        服务器在内存中保存会话对象，浏览器怎么保存会话id呢？​        每次发送http请求时浏览器自动发送会话id，cookie机制正好用来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value“形式存储，浏览器发送http请求时自动附带cookie信息​        tomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID”的cookie，这就是tomcat会话机制维护的会话id​        有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下\nHttpSession session = request.getSession();session.setAttribute(&quot;isLogin&quot;, true);用户再次访问时，tomcat在会话对象中查看登录状态HttpSession session = request.getSession();session.getAttribute(&quot;isLogin&quot;);\n\n​        每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。\n​        单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie，当跨域的时候，例如：\nsite1.comsite2.com\n\n​        这个时候就不能共享cookie了，所以上面的解决方案就会失效。​        既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。​        然而，可行并不代表好，共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。​        因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录\n单点登录​        英文全称Single Sign On，简称就是SSO。它的解释是：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统，包括登录注销两部分。\n1、登录　　相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明\n\n1.用户访问系统1的受保护资源，客户端过滤器拦截客户端的请求判断是否有局部session，如果有局部session，说明已经登录，直接放行，否则跳转至sso认证中心登录。\n//判断是否有局部的会话Boolean isLogin = (Boolean) session.getAttribute(&quot;isLogin&quot;);if(isLogin!=null &amp;&amp; isLogin)&#123;   \t//有局部会话,直接放行.   \tchain.doFilter(request, response);   \treturn;&#125;else&#123;\tresponse.sendRedirect(&quot;http://www.sso.com:8443/checkLogin&quot;);\t &#125;\n\n2.sso认证中心发现用户未登录，将用户引导至登录页面\n@RequestMapping(&quot;/checkLogin&quot;)\npublic String checkLogin(String redirectUrl, HttpSession session,Model model)&#123;\n    //判断是否有全局的会话\n    String token = (String) session.getAttribute(&quot;token&quot;);\n    if(StringUtils.isEmpty(token))&#123;\n        //表示没有全局会话\n        //跳转到统一认证中心的登陆页面.\n        model.addAttribute(&quot;redirectUrl&quot;,redirectUrl);\n        return &quot;login&quot;;\n    &#125;else&#123;\n        //有全局会话\n        //取出令牌信息,重定向到redirectUrl,把令牌带上  http://www.wms.com:8089/main?token\n        model.addAttribute(&quot;token&quot;,token);\n        return &quot;redirect:&quot;+redirectUrl;\n    &#125;\n&#125;\n\n4.sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌\n5.sso认证中心带着令牌跳转会最初的请求地址（系统1）\n@RequestMapping(&quot;/user_login&quot;)public String login(String username,String password,String \t\t\t\t\t   redirectUrl,HttpSession session,Model model)&#123;    \t\t\t\t\t\t\t\t\t\t\tif(&quot;admin&quot;.equals(username)&amp;&amp;&quot;123456&quot;.equals(password))&#123;\t\t//账号密码匹配       \t\t//1.创建令牌信息       \t\t\t\t\tString token = UUID.randomUUID().toString();       \t\t//2.创建全局的会话,把令牌信息放入会话中.        \t\t\t\t\t\t\t\t\t\t\t\tsession.setAttribute(&quot;token&quot;,token);       \t\t//3.需要把令牌信息放到数据库中.       \t\tMockDatabaseUtil.T_TOKEN.add(token);        \t\t\t\t\t\t\t\t\t\t\tsession.setAttribute(&quot;username&quot;,username);        \t\t\t\t\t\t\t\t\t\tif(StringUtils.isEmpty(redirectUrl))&#123;      \t\treturn &quot;redirect:/&quot;;      \t\t&#125;       \t\t//4.重定向到redirectUrl,把令牌信息带上.         \t\t\t\t\t\t\t\t\t\t\tmodel.addAttribute(&quot;token&quot;,token);    \t\treturn &quot;redirect:&quot;+redirectUrl;   \t&#125;   \t\t//如果账号密码有误,重新回到登录页面,还需要把redirectUrl放入request域中.    \t\t\t\t\t\tif(!StringUtils.isEmpty(redirectUrl))&#123;        \t\t\t\t\t\t\t\t\t\t\t\tmodel.addAttribute(&quot;redirectUrl&quot;,redirectUrl);  \t\t&#125;  \t\treturn &quot;redirect:login&quot;;&#125;\n\n6.系统1拿到令牌，去sso认证中心校验令牌是否有效\n7.校验令牌，返回有效，注册系统1\n//判断地址栏中是否有携带token参数.String token = req.getParameter(&quot;token&quot;);if(StringUtils.isNoneBlank(token))&#123;   \t//token信息不为null,说明地址中包含了token,拥有令牌.  \t//判断token信息是否由认证中心产生的.   \tString httpURL = SSOClientUtil.SERVER_URL_PREFIX+&quot;/verify&quot;;   \t\t\t\t\t\t\tMap&lt;String,String&gt; params = new HashMap&lt;String,String&gt;();   \t\t\t\t\t\t\tparams.put(&quot;token&quot;, token);  \tparams.put(&quot;clientUrl&quot;, SSOClientUtil.getClientLogOutUrl());   \t\t\t\t\t\t\tparams.put(&quot;jsessionid&quot;, session.getId());       \tString isVerify = HttpUtil.sendHttpRequest(httpURL, params);      \t\t\t\t\t\tif(&quot;true&quot;.equals(isVerify))&#123;        \t\t//如果返回的字符串是true,说明这个token是由统一认证中心产生的.    \t\t//创建局部的会话.       \t\tsession.setAttribute(&quot;isLogin&quot;, true);     \t\t//放行该次的请求   \t\tchain.doFilter(request, response);    \t\treturn;   \t&#125;  &#125;\n\n8.系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源\nsession.setAttribute(&quot;isLogin&quot;, true); chain.doFilter(request, response);\n\n9用户访问系统2的受保护资源10.系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数11.sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌12.系统2拿到令牌，去sso认证中心校验令牌是否有效13.sso认证中心校验令牌，返回有效，注册系统214.系统2使用该令牌创建与用户的局部会话，返回受保护资源\n2、注销　　单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明\n\n​        sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作，下面对上图简要说明\n1.用户向系统1发起注销请求2.系统1向sso认证中心发起注销请求\npublic static String getClientLogOutUrl()&#123;   \treturn &quot;http://www.crm.com:8088/logOut&quot;;&#125;req.setAttribute(&quot;serverLogOutUrl&quot;, getServerLogOutUrl());\n\n3.sso认证中心销毁全局会话\n@RequestMapping(&quot;/logout&quot;)public String logout(HttpServletRequest req) &#123;    HttpSession session = req.getSession();    if (session != null) &#123;        session.invalidate();//触发LogoutListener    &#125;    return &quot;redirect:/&quot;;&#125;\n\n4.sso认证中心监听器检测监测到session销毁，向所有注册系统发起注销请求5.各注册系统接收sso认证中心的注销请求，销毁局部会话\n@Overridepublic void sessionDestroyed(HttpSessionEvent se) &#123;    HttpSession session = se.getSession();    String token = (String) session.getAttribute(&quot;token&quot;);    //删除令牌数据    MockDatabaseUtil.T_TOKEN.remove(token);    List&lt;ClientInfoVo&gt; clientInfoVoList = MockDatabaseUtil.T_CLIENT_INFO.remove(token);          if(clientInfoVoList !=null)&#123;            \t\tfor(ClientInfoVo vo:clientInfoVoList)&#123;                \t\t//获取出注册的子系统,依次调用子系统的登出的方法                \t\t\t\t\t\t\t\t\tHttpUtil.sendHttpRequest(vo.getClientUrl(),vo.getJsessionid());        &#125;\t&#125;&#125;\n\n6.sso认证中心引导用户至登录页面\nreturn &quot;redirect:login&quot;;\n\n\n\n——————来自技术分享，王宇\n","categories":[],"tags":["技术分享"]},{"title":"SpringBoot 整合阿里云短信接口完成注册","url":"/2019/10/15/SpringBoot-%E6%95%B4%E5%90%88%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%AE%8C%E6%88%90%E6%B3%A8%E5%86%8C/","content":"SpringBoot 整合阿里云短信接口完成注册准备工作\n准备一个阿里云账号\n\n开通短信服务\n\n获取accesskeys（AccessKeyID和AccessKeySecret）\n\n\n\nRAM访问控制-&gt;新建用户**（选择编程访问，及时保存AccessKeyID和AccessKeySecret。）\n\n添加权限\n\n\n获取签名（签名名称）\n按要求创建即可\n\n获取短信模板（模版CODE）\n按要求创建即可\n\n充值\n\n\n代码引入依赖：\n&lt;dependency&gt;          &lt;groupId&gt;com.aliyun&lt;/groupId&gt;          &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;          &lt;version&gt;4.0.6&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.aliyun&lt;/groupId&gt;          &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt;          &lt;version&gt;1.1.0&lt;/version&gt;      &lt;/dependency&gt;\n\n\n\nutil工具类：\n   //产品名称:云通信短信API产品 无需替换   static final String product = &quot;Dysmsapi&quot;;   //产品域名  无需替换   static final String domain = &quot;dysmsapi.aliyuncs.com&quot;;// 这两个换成自己的   static final String accessKeyId = &quot;...&quot;;   static final String accessKeySecret = &quot;...&quot;;   //随机生成验证码   private static int newcode;   public static int getNewcode() &#123;       return newcode;   &#125;   public static void setNewcode() &#123;       newcode = (int) (Math.random() * 8999) + 1000;  //每次调用生成一位四位数的随机数   &#125;   public static &lt;IClientProfile&gt; SendSmsResponse sendSms(String telephone, String code) throws ClientException &#123;       //调整超时时间       System.setProperty(&quot;sun.net.client.defaultConnectTimeout&quot;, &quot;10000&quot;);       System.setProperty(&quot;sun.net.client.defaultReadTimeout&quot;, &quot;10000&quot;);       //初始化acsClient,暂不支持region化       IClientProfile profile = (IClientProfile) DefaultProfile.getProfile(&quot;cn-hangzhou&quot;, accessKeyId, accessKeySecret);       DefaultProfile.addEndpoint(&quot;cn-hangzhou&quot;, &quot;cn-hangzhou&quot;, product, domain);       IAcsClient acsClient = new DefaultAcsClient((com.aliyuncs.profile.IClientProfile) profile);       //组装请求对象       SendSmsRequest request = new SendSmsRequest();       //待发送手机号       request.setPhoneNumbers(telephone);       //这两个全换成自己的   \t//必填:短信签名-可在短信控制台中找到       request.setSignName(&quot;...&quot;);        //必填:短信模板-可在短信控制台中找到       request.setTemplateCode(&quot;...&quot;);       //模板中的变量替换JSON串       request.setTemplateParam(&quot;&#123;\\&quot;code\\&quot;:\\&quot;&quot; + code + &quot;\\&quot;&#125;&quot;);       //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者       request.setOutId(&quot;yourOutId&quot;);       //hint 此处可能会抛出异常，注意catch       SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request);       if (sendSmsResponse.getCode() != null &amp;&amp; sendSmsResponse.getCode().equals(&quot;OK&quot;)) &#123;           System.out.println(&quot;短信发送成功！&quot;);       &#125; else &#123;           System.out.println(&quot;短信发送失败！&quot;);       &#125;       return sendSmsResponse;   &#125;\n\ncontroller层\n/**    * 注册前判断+阿里云短信    * @param telephone    * @return    */   @RequestMapping(&quot;send&quot;)   @ResponseBody   public ResultData sendShortMessage(String telephone)&#123;       ResultData resultData = new ResultData();       User user = userService.selectRegisterByTelephone(telephone);       System.out.println(telephone);       //生成一个验证码       setNewcode();       //获取它、打印它       String code = Integer.toString(getNewcode());       System.out.println(&quot;发送的验证码为：&quot; + code);       SendSmsResponse sendSmsResponse = null;       //发短信       try &#123;           sendSmsResponse = sendSms(telephone, code);       &#125; catch (ClientException e) &#123;           e.printStackTrace();       &#125;       System.out.println(&quot;短信接口返回的数据----------------&quot;);       System.out.println(&quot;Code=&quot; + sendSmsResponse.getCode());       System.out.println(&quot;Message=&quot; + sendSmsResponse.getMessage());       System.out.println(&quot;RequestId=&quot; + sendSmsResponse.getRequestId());       System.out.println(&quot;BizId=&quot; + sendSmsResponse.getBizId());       /*if(sendSmsResponse.getCode() != null &amp;&amp; sendSmsResponse.getCode().equals(&quot;OK&quot;))&#123;           resultData.setCode(0);           resultData.setData(code);       &#125; else&#123;           resultData.setCode(1);           resultData.setMessage(&quot;短信发送失败！！&quot;);       &#125;*/       if(user != null)&#123;           resultData.setCode(1);           resultData.setMessage(&quot;当前用户已经存在&quot;);           return resultData;       &#125; else &#123;           resultData.setData(code);           resultData.setCode(0);       &#125;       return resultData;   &#125;            /**    * 注册    * @param number    * @param pwd    * @return    */   @RequestMapping(&quot;register&quot;)   @ResponseBody   public ResultData register(String number,String pwd)&#123;       ResultData resultData = new ResultData();       Integer count = userService.insertUser(number,pwd);       if (count&gt;0)&#123;           resultData.setData(count);           resultData.setCode(0);       &#125; else &#123;           resultData.setCode(1);           resultData.setMessage(&quot;添加失败&quot;);       &#125;       return resultData;   &#125;\n\n——————来自技术分享，刘兰波\n","categories":[],"tags":["技术分享","SpringBoot"]},{"title":"AJAX在不同html页面之间的传值","url":"/2019/10/15/AJAX%E5%9C%A8%E4%B8%8D%E5%90%8Chtml%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/","content":"AJAX在不同html页面之间的传值今天在做注册的时候，发现了一个很严重的问题，第一个注册页面是填用户名密码，然后在controller判断用户名是否存在，不存在的话给他发验证码，然后跳到第二个页面，第二个页面填验证码，如果验证码正确就将用户信息插入到数据库并跳转到第三个页面，但是在第一个页面和第二个页面传值的时候，犯了一个很大的错误\n\n\n这是页面1的ajax\n &lt;!--判断两次密码是否一致--&gt; &lt;script&gt; function validate() &#123;\tvar pwd = $(&quot;#pwdOnce&quot;).val();\tvar pwd1 = $(&quot;#pwdTwice&quot;).val();\t&lt;!-- 对比两次输入的密码 --&gt;\tif(pwd == pwd1)&#123;            $(&quot;#tishi&quot;).html(&quot;两次密码相同&quot;);            $(&quot;#tishi&quot;).css(&quot;color&quot;,&quot;green&quot;);            $(&quot;#xiugai&quot;).removeAttr(&quot;disabled&quot;);            return true;\t\t&#125; else &#123;            $(&quot;#tishi&quot;).html(&quot;两次密码不相同&quot;);            $(&quot;#tishi&quot;).css(&quot;color&quot;,&quot;red&quot;)            $(&quot;button&quot;).attr(&quot;disabled&quot;,&quot;disabled&quot;);            return false;\t\t&#125;\t&#125;&lt;/script&gt; &lt;!-- ajax代码 --&gt;&lt;script&gt;$(&quot;#step1Submit&quot;).click(function () &#123;// 如果两次密码输入一致if(validate()==true)&#123;\t// 获取表单中填写的手机号和密码\tvar tel = $(&quot;#mobileNum&quot;).val()\tvar pwd = $(&quot;#pwdOnce&quot;).val()\t// 发送ajax请求\t$.ajax(&#123;\t\ttype: &quot;POST&quot;,\t\turl: &quot;/user/send&quot;,\t\tdata:&#123;        \ttelephone:tel\t        &#125;,        success: function(result)&#123;       \t\tif (result.code==1)&#123;       \t\t// 当前用户已存在        \t\talert(result.message)\t\t\t&#125; else &#123;\t\t\t// 把手机号 验证码 密码 都通过url传到第二页                location.href=&quot;register2.html&quot; tel=&quot;+tel+&quot;&amp;code=&quot;+result.data+&quot;&amp;pwd=&quot;+pwd\t\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;)\t&#125;&#125;)&lt;/script&gt;\n\n\n\n第二页ajax\n&lt;!--拿上个页面的手机号和验证码--&gt;&lt;script&gt;    $.getUrlParam = function (name) &#123;        var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);        var r = window.location.search.substr(1).match(reg);        if (r != null) return unescape(r[2]);          // 如果传的参数有中文，用下面这个        //  if (r != null) return decodeURI(r[2]);                 return null;           &#125;\t// 从url中拿参数    var tel = $.getUrlParam(&#x27;tel&#x27;)    // 把拿到的手机号放到指定控件    $(&quot;#urltel&quot;).html(tel)\t// 从url中拿验证码和密码    var code = $.getUrlParam(&#x27;code&#x27;)    var pwd1 = $.getUrlParam(&#x27;pwd&#x27;)    $(&quot;#step2Submit&quot;).click(function () &#123;\t\t\t\t// 取用户输入的验证码        var telCode = $(&quot;#mobileVerifCode&quot;).val()\t\t\t\t// 输入的验证码正确 提交用户名密码  转到第三个页面        if(telCode == code)&#123;            $.ajax(&#123;                type: &quot;POST&quot;,                url: &quot;/user/register&quot;,                data:&#123;                    number:tel,                    pwd:pwd1,                &#125;,                success: function(result)&#123;                    if (result.code==1)&#123;                        alert(result.message)                    &#125; else &#123;                        location.href=&quot;register3.html&quot;                    &#125;                &#125;            &#125;)        &#125;    &#125;)&lt;/script&gt;\n\n\n\n\n\n本以为参数是都传过去了，乐呵呵的做别的去了，结果第二天检查代码让我虎躯一震\n\n所有信息都暴露在url上，这不废废了吗，然后左问右问，别人告诉我先把参数存到session，用的话再拿出来\n修改的ajax代码如下\n第一个页面\n$.ajax(&#123;\t\ttype: &quot;POST&quot;,\t\turl: &quot;/user/send&quot;,\t\tdata:&#123;        \ttelephone:tel\t        &#125;,        success: function(result)&#123;       \t\tif (result.code==1)&#123;       \t\t// 当前用户已存在        \t\talert(result.message)\t\t\t&#125; else &#123;\t\t\t// 把手机号 验证码 密码 存到session\t\t\t\tsessionStorage.setItem(&quot;tel&quot;,tel)                sessionStorage.setItem(&quot;pwd&quot;,pwd)\t            sessionStorage.setItem(&quot;code&quot;,result.data)\t                            location.href=&quot;register2.html&quot;\t\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;)\n\n第二个页面\n// 从session中拿这三个参数var tel = sessionStorage.getItem(&quot;tel&quot;)  var code = sessionStorage.getItem(&quot;code&quot;)  var pwd1 = sessionStorage.getItem(&quot;pwd&quot;)  $(&quot;#urltel&quot;).html(tel)  $(&quot;#step2Submit&quot;).click(function () &#123;      var telCode = $(&quot;#mobileVerifCode&quot;).val()      if(telCode == code)&#123;          $.ajax(&#123;              type: &quot;POST&quot;,              url: &quot;/user/register&quot;,              data:&#123;                  number:tel,                  pwd:pwd1,              &#125;,              success: function(result)&#123;                  if (result.code==1)&#123;                      alert(result.message)                  &#125; else &#123;                      location.href=&quot;register3.html&quot;                  &#125;              &#125;          &#125;)      &#125; else &#123;          alert(&quot;验证码错误&quot;)      &#125;  &#125;)\n\n这样，参数顺利的拿到了！\n","categories":[],"tags":["bug"]},{"title":"AJAX页面跳转时不刷新","url":"/2019/10/15/AJAX%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%97%B6%E4%B8%8D%E5%88%B7%E6%96%B0/","content":"AJAX页面跳转时不刷新做项目时订单页面和订单详情页面跳转时，页面没有刷新，再手动刷新一下就都出来了\n订单页跳转\n&lt;span class=&quot;list_cz&quot;&gt;      &lt;a class=&quot;infoorder&quot; href=&quot;localhost:8080/userhtml/orderdetail.html?orderId=$&#123;result.data[i].orderFormId&#125;&quot; &gt;      查看订单      &lt;/a&gt; &lt;/span&gt;\n\n\n\n\n\n订单详情ajax\n&lt;script&gt;\t\t\t\t// 从url上拿参数               $.getUrlParam = function (name) &#123;                   var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);                   var r = window.location.search.substr(1).match(reg);                   if (r != null) return unescape(r[2]); return null;               &#125;               var orderId = $.getUrlParam(&#x27;orderId&#x27;)                                $.ajax(&#123;                        type:&quot;POST&quot;,                        url:&quot;http://localhost:8080/order/selectOrderByOrderId&quot;,                        data:&#123;                            orderId:orderId,                        &#125;,                        dataType:&quot;json&quot;,                        success:function (result) &#123;                            if(result.code==1)&#123;                                alert(result.message)                            &#125; else &#123;                                $(&quot;#allmoney&quot;).html(result.data.originPrice)                                $(&quot;#orderid&quot;).html(result.data.orderFormNumber)                                $(&quot;#orderstatus&quot;).html(result.data.orderFormStatus)                                $(&quot;#hotelName&quot;).html(result.data.hotelName)                                $(&quot;#hotelposition&quot;).html(result.data.hotelPositon)                                $(&quot;#hotelPhoneNumber&quot;).html(result.data.hotelPhoneNumber)                                $(&quot;#ruzhuname&quot;).html(result.data.userName)                                $(&quot;#userTel&quot;).html(result.data.userPhoneNumber)                                $(&quot;#startTime&quot;).html(result.data.arriveDate)                                $(&quot;#endTime&quot;).html(result.data.leaveDate)                                $(&quot;#roomName&quot;).html(result.data.hotelRoomName)                            &#125;                        &#125;                    &#125;)       &lt;/script&gt;\n\n询问了大佬之后，发现是一个很小的问题\n跳转的时候没有加http！\n改了订单页url，加上http://\n&lt;span class=&quot;list_cz&quot;&gt;    &lt;a class=&quot;infoorder&quot; href=&quot;http://localhost:8080/userhtml/orderdetail.html?orderId=$&#123;result.data[i].orderFormId&#125;&quot; &gt;    查看订单    &lt;/a&gt;&lt;/span&gt;\n\n","categories":[],"tags":["bug"]},{"title":"MySQL事务","url":"/2019/10/15/MySQL%E4%BA%8B%E5%8A%A1/","content":"事务事务的概念什么是事务？\n一个事务是一个完整的业务逻辑单元，不可再分。\n和事务相关的语句只有DML语句（insert delete update）\n因为这三个语句都是和数据库表中的数据相关的\n事务的存在是为了保证数据的完整性，安全性\n\n\n假设所有业务都能使用一条DML搞定，还需要事务机制吗？\n不需要\n但实际情况不是这样的，通常一个事需要多条DML语句共同联合完成\n事务的原理假设一个事，需要先执行一条insert，再执行一条update，最后执行一条delete，这个事才算完成。\n\n开始事务机制（开始）\n\n```执行insert语句，（这个执行成功之后，把这个执行记录到数据库的操作历史中，并不会向文件中保存一条数据，不会真正的修改硬盘上的数据）\n\n执行update语句，（这个执行也是记录一下历史操作，不会真正的修改硬盘上的数据）\n\n执行delete语句，（这个执行也是记录一下历史操作【记录到缓存】，不会真正的修改硬盘上的数据）\n   3. 提交事务或者回滚事务（结束）   - 提交事务：commit 硬盘数据改变，历史记录清空   - 回滚事务：rollback 硬盘数据不改变，历史记录清空savepoint 保存点，比如你做一个事，先insert,delete,update，然后你在这savepoint a1； 然后你再delete,update........ 然后你rollback a1，这时回滚到a1保存点，目的就是回滚滚到一个地方。（很少用）## 事务的四大特性事务包括四大特性：ACID- A：原子性：事务是最小的工作单元，不可再分。- C：一致性：事务必须保证多条DML语句同时成功或者同时失败。- I： 隔离性：事务A与事务B之间具有隔离，保证数据的安全。- D：持久性：数据最终必须持久化到硬盘文件中，事务才算成功地结束。## 关于事务之间的隔离性事务隔离性存在隔离级别，理论上隔离级别包括4个：- 第一级别：读未提交（read uncommitted），对方事务还没提交，我们当前事务可以读取到对方未提交的数据。读未提交存在脏读（Dirty Read）现象，表示读到了脏的数据。- 第二级别：读已提交（read committed），对方事务提交之后的数据我方可以读取到。这种隔离级别解决了脏读现象。存在的问题：不可重复读。- 第三级别：可重复读（repeatable read），解决了不可重复读问题。存在的问题：读取到的数据是幻象。- 第四级别：序列化读/串行化读，解决了所有问题。效率低，需要事务排队。oracle数据库默认的隔离级别是：读已提交mysql数据库默认的隔离级别是：可重复读## 演示事务- mysql事务默认情况下是自动提交的。（什么是自动提交？只要执行任意一条DML语句则提交一次。）怎么关闭自动提交？start transaction\ncreate table student(id int PRIMARY key auto_increment,sname varchar(20))\n\n\n  insert into student(sname) values(‘zs’)\n  select * from student\n  rollback \n  select * from student    演示：mysql中的事务是支持自动提交的，只要执行一条DML，则提交一次。- 演示：使用start transaction关闭自动提交机制  - 回滚    start TRANSACTION\ninsert into student(sname) values (&#39;ls&#39;)\n\nselect * from student\n\nrollback\n\nselect * from student\n  - 提交\nstart TRANSACTION\n\ninsert into student(sname) values(&#39;qq&#39;)\ninsert into student(sname) values(&#39;ee&#39;)\n\ncommit\n\nselect * from student\n\nROLLBACK\n\nselect * from student\n## 使用两个事务以上演示- 第一：演示read uncommitted  设置事务的全局隔离级别\n\n  set global transaction isolation level read committed  查看事务的全局隔离级别  select @@glibal.tx_isolation\n  ```\n","categories":[],"tags":["MySQL"]},{"title":"女友都能看懂的SSM整合","url":"/2019/10/15/%E5%A5%B3%E5%8F%8B%E9%83%BD%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84SSM%E6%95%B4%E5%90%88/","content":"SSM整合1. 创建java项目2. 创建maven module 要选webapp\n\n3. pom除了依赖 没用的模板的东西都删了\n4. 建文件夹\n\n\n\n然后ok\n5. 添加pom依赖添加properties&lt;properties&gt;        &lt;spring.version&gt;5.1.5.RELEASE&lt;/spring.version&gt;        &lt;commons.logging&gt;1.2&lt;/commons.logging&gt;        &lt;mybatis&gt;3.5.2&lt;/mybatis&gt;        &lt;mysql.connector&gt;5.1.47&lt;/mysql.connector&gt;        &lt;log4j&gt;1.2.17&lt;/log4j&gt;        &lt;mybatis.spring&gt;2.0.1&lt;/mybatis.spring&gt;        &lt;druid.version&gt;1.1.16&lt;/druid.version&gt;    &lt;/properties&gt;\n\n添加spring mybatis依赖还有build&lt;dependencies&gt;&lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.11&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-logging&lt;/groupId&gt;            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;            &lt;version&gt;$&#123;commons.logging&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;$&#123;mybatis&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;$&#123;mysql.connector&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;$&#123;log4j&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;$&#123;mybatis.spring&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;!--此配置不可缺，否则mybatis的Mapper.xml将会丢失--&gt;                &lt;!--&lt;includes&gt;--&gt;                &lt;!--换成你所在xml文件的所在路径--&gt;                &lt;!--&lt;include&gt;com/elife/mapper/*.xml&lt;/include&gt;--&gt;                &lt;!--&lt;/includes&gt;--&gt;            &lt;/resource&gt;            &lt;!--指定资源的位置--&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;\n\n添加springmvc依赖&lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/javax.servlet/servlet-api --&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;      &lt;version&gt;2.5&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;      &lt;version&gt;2.9.8&lt;/version&gt;    &lt;/dependency&gt;\n\n\n\n6. 改web.xml添加springmvc核心控制器&lt;!--核心/前端 控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  &lt;!-- 应用启动时，加载servlet --&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;!-- 约定优于配置，  Spring MVC框架默认加载/WEB-INF/&lt;servlet-name/&gt;开头-servlet.xml（即dispatcher-servlet.xml）作为配置文件载入Web工程中--&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;!-- 拦截配置 --&gt;    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;\n\n添加spring的xmlresources下建xml\n1.spring-dao.xml    用来配置数据库&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsdhttp://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!-- 注解与xml配置混合使用  相当于@CompomentScan--&gt;    &lt;context:component-scan base-package=&quot;com.elife.mapper&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 扫描接口，与其同名的xml文件 映射文件--&gt;    &lt;mybatis:scan base-package=&quot;com.elife.mapper&quot;&gt;&lt;/mybatis:scan&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt;    &lt;!-- 配置druid数据源连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;        &lt;property name=&quot;filters&quot; value=&quot;$&#123;jdbc.filters&#125;&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot; /&gt;        &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot; /&gt;        &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;jdbc.maxWait&#125;&quot; /&gt;        &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;jdbc.minIdle&#125;&quot; /&gt;        &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;$&#123;jdbc.timeBetweenEvictionRunsMillis&#125;&quot; /&gt;        &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;$&#123;jdbc.minEvictableIdleTimeMillis&#125;&quot; /&gt;        &lt;property name=&quot;validationQuery&quot; value=&quot;$&#123;jdbc.validationQuery&#125;&quot; /&gt;        &lt;property name=&quot;testWhileIdle&quot; value=&quot;$&#123;jdbc.testWhileIdle&#125;&quot; /&gt;        &lt;property name=&quot;testOnBorrow&quot; value=&quot;$&#123;jdbc.testOnBorrow&#125;&quot; /&gt;        &lt;property name=&quot;testOnReturn&quot; value=&quot;$&#123;jdbc.testOnReturn&#125;&quot; /&gt;        &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;$&#123;jdbc.poolPreparedStatements&#125;&quot; /&gt;        &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;$&#123;jdbc.maxPoolPreparedStatementPerConnectionSize&#125;&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n2.spring-service.xml  用来配置事务&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsdhttp://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!-- 注解与xml配置混合使用  相当于@CompomentScan--&gt;    &lt;context:component-scan base-package=&quot;com.elife.service.impl&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 使用注解驱动 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;    &lt;!--配置事务管理器--&gt;    &lt;bean id=&quot;transactionManager&quot;          class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:advice id=&quot;tx_advice&quot; transaction-manager=&quot;transactionManager&quot;&gt;    &lt;tx:attributes&gt;    &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot; /&gt;    &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; /&gt;    &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot; /&gt;    &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;aop:config&gt;    &lt;aop:pointcut expression=&quot;execution(* com.elife.service.impl.*.*(..))&quot;    id=&quot;tx_pc&quot; /&gt;    &lt;aop:advisor advice-ref=&quot;tx_advice&quot; pointcut-ref=&quot;tx_pc&quot;/&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\n3.spring-web.xml  用来配置springmvc&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsdhttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt;    &lt;!-- 启用Springmvc注解驱动 --&gt;    &lt;mvc:annotation-driven /&gt;    &lt;!-- 配置扫描注解的包 --&gt;    &lt;context:component-scan base-package=&quot;com.elife.controller&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--视图解析器，对controller返回的地址加上前缀与后缀，为其实际的转发地址--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n7. 测试1. 写controllerpackage com.elife.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class RoleController &#123;    @RequestMapping(&quot;test&quot;)    public String test()&#123;        return &quot;test&quot;;    &#125;&#125;\n\n2.建个jsp&lt;%--  Created by IntelliJ IDEA.  User: CodeKop  Date: 2019/9/7  Time: 10:23  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;测试通过&lt;/body&gt;&lt;/html&gt;\n\n3. 发布访问http://localhost:8080/ssmbook/test.do，测试通过\n8. 逆向工程1.新建Module，什么都不用选2.添加pom依赖&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.47&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!--配置Mybatis反向代理的插件--&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;                &lt;!--Exception getting JDBC Driver: com.mysql.jdbc.Driver，添加此处代码解决--&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;mysql&lt;/groupId&gt;                        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                        &lt;version&gt;5.1.47&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;\n\n3. 逆向工程\n4. 把对应文件都粘过去最后的项目结构：\n\n","categories":[],"tags":[]},{"title":"SpringMVC流程","url":"/2019/10/15/SpringMVC%E6%B5%81%E7%A8%8B/","content":"Spring执行流程讲解1-Controller处理器映射器\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\n处理器适配器\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\n实例化controller，同时调用方法\n\n\n在SpringMVC中进行配置\n&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;&lt;/bean&gt;   &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;&lt;/bean&gt;\n\n配置后可正常执行，但是实际工作中，不需要配置这么长的内容，只需要配置如下注解驱动\n&lt;mvc:annotation-driven /&gt;\n\n相当于使用最新的处理器与映射器，并对json响应提供支持\n讲解2-视图解析器&lt;bean           class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;       &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;       &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;\n\n前缀与后缀，简化view的设置\n讲解3-流程\n路径配置注意有个初始参数 contextConfigLocation， 顾名思义  上下文配置文件路径。\n还有另外一个注意点，这个servlet对应的url-pattern最好写成 “/“， 不要写成 “/*“。\n\n以 /* 结尾的。 path.endsWith(“/*“)\n\n以 *. 开头的。 path.startsWith(“*.”)\n\n是否是 /。      path.equals(“/“)\n\n以上3种之外的。\n\n\n/*会拦截jsp文件，而/不会\n参考地址\n","categories":[],"tags":["SpringMVC"]},{"title":"servlet","url":"/2019/10/15/servlet/","content":"Java Webtomcattomcat工作原理\n\n\nidea配置tomcat\n\n\n\n\n\n\n\n\n\nServlet定义\n问题：\n服务器在接收到浏览器的请求后，会自动调用对应的逻辑代码进行请求处理。但是逻辑代码是由程序员编写并放到服务器中，那么服务器怎么知道该怎么调用并调用哪个方法来实现请求处理？\n\n解决：\n程序员在编写代码的时候如果能够按照服务器能够识别的规则进行编写（接口），浏览器按照指定的规则进行发送请求，那么服务器就可以调用并执行相应的逻辑代码进行请求处理了。\n\n实现：Servlet技术\n\n概念：\n\n狭义的Servlet是指Java语言实现的一个接口\n广义的Servlet是指任何实现了这个Servlet接口的类\n一般情况下，人们将Servlet理解为后者。\n\n\n\n特点\n运行在支持java应用的服务器上\nServlet的实现遵循了服务器能够识别的规则，也就是服务器会自动的根据请求调用对应的servlet进行请求处理\n简单方便，可移植性强\n\n使用\n创建普通的java类并继承HttpServlet\n覆写service方法\n再service方法中写逻辑代码\n在webRoot下的WEB-INF文件夹下的web.xml文件中配置servlet\n\n组成URL‘组成：服务器地址：端口号/虚拟项目名/servlet的别名\nURI：虚拟项目名/servlet的别名\n运行流程\n浏览器发送请求到服务器\n服务器根据请求URL地址中的URL信息在webapps目录下找到对应的项目文件夹\n然后再web.xml中检索对应的servlet，找到后调用并执行servlet\n\nServlet的生命周期\n从第一次调用到服务器关闭\n如果Servlet在web.xml中配置了&lt;load-on-startup&gt; ，生命周期为 从服务器启动到服务器关闭\n\n注意：\n\ninit方法是对Servlet进行初始化的一个方法，会在Servlet第一次加载时进行存储执行\n\ndestory方法是在servlet被销毁时执行，也就是服务器关闭时。\n\n```1                数字代表加载顺序\n代码示例\npublic class FirstServlet extends HttpServlet {\n @Override  public void init(){\n System.out.println(&quot;servlet初始化完成&quot;);\n\n }\n\n\n   @Override    protected void service(HttpServletRequest req,HttpServletResponse resp) throws IOException {\n    resp.getWriter().write(&quot;servlet life&quot;);\n   System.out.println(&quot;servlet life&quot;);\n\n   }\n   @Override    public void destroy(){        System.out.println(“我被销毁了”);    }\n}\nxml配置\n&lt;!--配置Servlet的访问--&gt;\n&lt;servlet&gt;\n    &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;aa.FirstServlet&lt;/servlet-class&gt;\n\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    \n\n&lt;/servlet&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/fs&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n\n## service方法和doGet方法和doPost方法的使用和区别- service方法：可以处理get/post方式的请求，如果servlet中有service方法，会优先调用service方法对请求的处理- doGet方法：处理get方式的请求- doPost方法：处理post方式的请求注意：​\t如果在覆写的service方法中调用了父类的service方法`super.service(arg0,arg1);`​\t则在service方法处理完后，会再次根据请求方式响应的doGet和doPost方法执行​\t必须写doGet和doPost方法，否则会405​\t所以，一般我们不再覆写的service中调用父类的service方法，避免出现405\n/**\n\nService方法 doGet方法  doPost方法\n/\n\n@WebServlet(name = “ServletMethod”)public class ServletMethod extends HttpServlet {/*    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        System.out.println(“我是service”);    }*/\n   @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        System.out.println(“我是doGet”);    }/*    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        System.out.println(“我是doPost”);    }*/}\n## Servlet的常见错误- 404错误：资源未找到  - 原因一：在请求地址中的servlet的别名书写错误  - 原因二：虚拟项目名称拼写错误- 500错误：内部服务器错误  - 错误一：空指针    解决：在web.xml中校验servlet类的全限定路径是否拼写错误  - 错误二：因为service方法体的代码执行错误导致    解决：根据错误提示对service方法体中的代码进行错误更改- 405错误：请求方式不支持  - 原因：请求方式和servlet中的方法不匹配所造成的  - 解决：尽量使用service方法进行请求处理，并且不要在service方法中调用父类的service## request对象- 作用：request对象中封存了当前请求的所有请求信息- 使用：  - 获取请求头数据  - 获取请求行数据  - 获取用户数据- 注意：  request对象由tomcat服务器创建，并作为实参传递给处理请求的servlet的service方法。\n/**\n\nrequest对象学习\n\n 作用：request对象中封存了当前请求的所有请求信息\n\n 使用：获取请求头数据\n\n         getMethod();        // 获取请求方式\n\n\n         getRequestURL();    // 获取请求URL信息\n\n\n         getRequestURI();    // 获取请求URI信息\n\n\n         getScheme();        // 获取协议\n\n\n   获取请求行数据\n\n\n            getHeader(&quot;键名&quot;);     // 返回指定的请求头信息\n\n\n            getHeaderNames();      // 返回请求头的键名的枚举集合\n\n\n   获取请求用户数据\n\n\n            getParameter(&quot;键名&quot;);  // 返回指定的用户数据\n\n\n            getParameterValues(&quot;键名&quot;);  //返回同键不同值的请求数据（多选），返回的是数组\n\n\n            req.getParameterNames()   //返回所有的用户请求数据的键的枚举集合\n\n\n            注意： 如果要获取的请求数据不存在，不会报错，返回null\n\n\n  注意：request对象由tomcat服务器创建，并作为实参传递给处理请求的servlet的service方法\n\n/@WebServlet(name = “RequestServlet”)public class RequestServlet extends HttpServlet {  @Override  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  // 获取请求头数据\n  // 获取请求方式\n  String method = req.getMethod();\n  System.out.println(method);\n\n  // 获取请求URL\n  StringBuffer url = req.getRequestURL();\n  System.out.println(url);\n      // 获取URI\n      String uri = req.getRequestURI();\n  System.out.println(uri);\n\n  // 获取协议(HTTP)\n  String x = req.getScheme();\n  System.out.println(x);\n\n\n\n // 获取请求行数据\n\n    // 根据指定键来获取行信息\n        String value = req.getHeader(&quot;Host&quot;);    //获取键，在网页 f12 network 找请求头里的key\n        System.out.println(value);\n\n    // 获取所有的请求行的键的枚举\n    Enumeration e = req.getHeaderNames();\n   while(e.hasMoreElements()) &#123;     //遍历键值对\n       String name = (String)e.nextElement();\n       String value2 = req.getHeader(name);\n       System.out.println(name+&quot;:&quot;+value2);\n    &#125;\n\n// 获取用户数据\n\n    String name = req.getParameter(&quot;uname&quot;);    // 如果后台数据写的键名和提交数据的键名不一致  就null\n    String pwd = req.getParameter(&quot;pwd&quot;);\n    System.out.println(name+&quot;:&quot;+pwd);\n\n    // 获取同键不同值的多项选择数据，getParameter不行，会漏值\n    String fav = req.getParameter(&quot;fav&quot;);\n    System.out.println(fav);\n\n    // 获取同键不同值多项选择数据，要用getParameterValues\n    // 注意有个坑，如果你要取的数据不存在，favs为null，你再遍历null，会空指针异常，写个判断更严谨\n    String[] favs = req.getParameterValues(&quot;fav&quot;);\n    if(null != favs) &#123;\n        for (String f : favs\n        ) &#123;\n            System.out.println(f);\n        &#125;\n    &#125;\n\n    //获取所有的用户请求数据的键的枚举集合  --&gt; req.getParameterNames()\n\n&#125;\n\n}\n ## response对象\n/**\n\nResponse对象学习\n 作用：用来响应数据到浏览器的一个对象\n 使用：\n 设置响应头\n\n\n     setHeader(String name, String value); // 在响应头中添加响应信息，但是同键会覆盖\n\n\n     addHeader(String name, String value); // 在响应头中添加响应信息，同键不同值不会覆盖\n\n\n 设置相应实体\n\n\n     resp.getWriter().write(String str); // 响应具体的数据给浏览器\n\n\n\n 设置响应状态\n\n\n     sendError(int num,String str);  // 自定义响应状态码\n\n\n 设置响应编码格式\n\n\n     resp.setContentType(&quot;text/html;charset=utf-8&quot;);\n\n\n\n  总结：\n service 请求代码处理流程\n\n\n     设置响应编码格式\n\n\n     获取请求数据\n\n\n     处理请求数据\n\n\n         数据库操作\n\n\n     响应处理结果\n\n\n/\n\n@WebServlet(name = “ResponseServlet”)public class ResponseServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // 获取请求信息            // 获取请求头            // 获取请求行            // 获取用户数据        // 处理请求        // 响应处理结果            // 设置响应头            resp.setHeader(“mouse”,”luoji”);            resp.setHeader(“mouse”,”shuang fei yan”);   // setHeader会覆盖\n        resp.addHeader(&quot;key&quot;,&quot;thinkpad&quot;);\n        resp.addHeader(&quot;key&quot;,&quot;cherry&quot;);     // addHeader不会覆盖\n        // 设置响应编码格式\n    // resp.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);    // 写下面的 一样的\n        resp.setContentType(&quot;text/html;charset=utf-8&quot;);     //html\n       // resp.setContentType(&quot;text/plain;charset=utf-8&quot;);  //文本\n       // resp.setContentType(&quot;text/xml;charset=utf-8&quot;);    //xml\n        // 设置响应状态码\n    //  resp.sendError(404,&quot;404la xiao huo zi&quot;);\n        // 响应实体\n        resp.getWriter().write(&quot;&lt;b&gt;今天真好this is response getWriter&lt;/b&gt;&quot;);\n&#125;\n\n}\n## 请求转发作用：实现了多个servlet联动操作处理请求，避免代码冗余，让servlet的职责更加明确。使用：\nreq.getRequestDispatcher(“要转发的地址”).forward(req,resp);\n特点：一次请求，浏览器地址栏不改变## request对象的作用域问题：使用请求转发后，不同的servlet之间怎么进行数据的共享呢？或者说数据怎么从一个servlet流转给另外一个servlet呢？使用:\nrequest.setAttribute(Object name,object value);request.getAttribute(Objdeect ob)\n作用：解决了一次请求内的不同的servlet的数据共享问题作用域：基于请求转发，一次请求中的所有servlet共享注意：使用request对象进行数据流转，数据旨在一次请求内创建特点：- 服务器创建- 每次请求都会创建- 生命周期一次请求## 重定向问题：- 如果当前的请求，servlet无法进行处理怎么办？- 如果使用请求转发，造成表单数据重复提交怎么办？解决：使用重定向使用：\nresponse.sendRedirect(“路径”);\n示例：\nresp.sendRedirect(“/login/main”);\n比如：淘宝买东西，支付的时候跳到支付宝再比如：你来我这盖章，我说我这盖不了，得去别的部门盖，这就是把你的请求重定向了，定给了别的部门主要作用：1. 避免表单数据重复提交2. 如果当前请求无法处理，重定向给其他的servlet或功能模块进行处理特点：- 两次请求，两个request对象- 浏览器地址栏信息改变使用时机：- 如果请求中有表单数据，而数据又比较重要，不能重定向，建议使用重定向- 如果请求呗servlet接收后，无法进行处理，建议使用重定向到可以处理的资源## cookie\n/**\n\ncookie学习\n 作用：解决了发送的不同请求的数据共享问题\n 使用：\n Cookie的创建和存储\n\n\n  创建cookie对象\n\n\n         Cookie c = new Cookie(String name,String value);\n\n\n     设置cookie（可选）\n\n\n         设置有效期\n\n\n         c.setMaxAge(int seconds);\n\n\n         设置有效路径\n\n\n         c.setPath(String uri);\n\n\n     响应cookie信息给客户端\n\n\n       resp.addCookie(c);\n\n\n Cookie的获取\n\n\n     获取cookie信息数组\n\n\n     Cookie[] cks = req.getCookies();\n\n\n     遍历数组获取Cookie信息 示例：\n\n\n      if(cks!= null)&#123;\n\n\n        for (Cookie c:cks) &#123;\n\n\n              String name = c.getName();\n\n\n              String value = c.getValue();\n\n\n              System.out.println(name+&quot;:&quot;+value);\n\n\n            &#125;\n\n\n         &#125;\n\n\n\n 注意：\n 一个cookie对象存储一条数据，多条数据 可以多创建几个cookie对象进行存储\n\n\n 特点：\n 浏览器端的数据存储技术\n\n\n 存储的数据声明在服务器端\n\n\n 临时存储：存储在浏览器的运行内存中，浏览器关闭即失效\n\n\n 定时存储：设置了Cookie的有效期，存储在客户端的硬盘中，在有效期内符合路径要求的请求都会附带该信息\n\n\n 默认cookie信息存储好之后，每次请求都会附带，除非设置有效路径\n\n\n\n\n/\n\n@WebServlet(name = “CoolieServlet”,value = “/cookie”)public class CookieServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //设置请求编码格式        req.setCharacterEncoding(“utf-8”);        //设置响应编码格式        resp.setContentType(“text/html;charset=utf-8”);        //获取请求信息        //处理请求信息        //响应处理结果            //使用cookie进行浏览器端的数据存储                //创建cookie对象                Cookie c = new Cookie(“mouse”,”luoji”);                Cookie c2 = new Cookie(“key”,”fg”);                //设置Cookie                    //设置Cookie的有效期                    c2.setMaxAge(3243600);    //设置cookie存3天 里面是秒                    //设置有效路径                    c2.setPath(“/cookie/abc”);                //响应cookie信息                resp.addCookie(c);                resp.addCookie(c2);            //直接响应            resp.getWriter().write(“cookie学习”);            //请求转发            //重定向    }}\n\n## web工程文件夹\n\n- pojo 放实体类\n- service 业务层  操作数据库和控制层\n- dao层 操作数据库\n- controller层 操作servlet\n\n\n\n\n\n","categories":[],"tags":["JavaWeb"]},{"title":"命令行打开软件","url":"/2019/10/15/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6/","content":"Win+R 快速打开软件首先把你想要设置的软件快捷方式弄到桌面\nwin+r 输入\n%windir%\n\n\n\n\n把你想要设置的软件快捷方式复制到文件夹内\n\n之后就可以通过win+r 直接快速访问啦！\n\n\n","categories":[],"tags":["电脑"]},{"title":"idea连接码云","url":"/2019/10/15/idea%E8%BF%9E%E6%8E%A5%E7%A0%81%E4%BA%91/","content":"idea连接码云流程\n\n一、打开码云网站注册并登陆二、建立远程仓库队长操作（1）右上角新建仓库\n（2）填写好仓库信息完成创建\n（3）点击管理-》项目成员管理-》管理员-》右上角添加用户成员邀请小组成员\n队员操作​    \n（1）点击右上角消息（2）点击私信进入同意请求三、本地idea连接码云1.用idea新建一个项目2.点击vcs-》import…-&gt;create…初始化git（等于git init）3.建立忽略(1)右键项目根目录新建忽略文件，文件名为.gitignore\n（2）复制以下代码到该文件，也可以百度查idea         git的忽略文件HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**!**/src/test/**### IntelliJ IDEA ###.idea*.iws*.iml*.ipr\n\n4.连接远程仓库点击vcs-&gt;git-&gt;remote-&gt;将远程仓库地址添加进去\n\n5.队长建立项目初始的结构（1）在根目录右键选择git -&gt;点击 add 再点击commit directory\n（2）在中间输入此次提交的备注信息\n（3）在根目录点击vcs-》git -》 push点击此处可以修改想提交的分支\n\n6.队员在根目录点击vcs-&gt;git-&gt;pull先点击下图的刷新按钮然后点击pull拉取远程分支的代码\n","categories":[],"tags":["git"]},{"title":"抽象类和接口","url":"/2019/10/15/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/","content":"抽象类和接口抽象类包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。\n\n没有实现\n子类必须实现\n\n\n\n抽象类的使用要点:\n​    1. 有抽象方法的类只能定义成抽象类\n​    2. 抽象类不能实例化，即不能用new来实例化抽象类。\n​    3. 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。\n​    4. 抽象类只能用来被继承。\n​    5. 抽象方法必须被子类实现。\n抽象方法​      使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。\n接口接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。\n​      抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。\n​      从接口的实现者角度看，接口定义了可以向外部提供的服务。\n​      从接口的调用者角度看，接口定义了实现者能提供那些服务。\n​      接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的具体实现了。大家在工作以后，做系统时往往就是使用“面向接口”的思想来设计系统。\n​      接口和实现类不是父子关系，是实现规则的关系。比如：我定义一个接口Runnable，Car实现它就能在地上跑，Train实现它也能在地上跑，飞机实现它也能在地上跑。就是说，如果它是交通工具，就一定能跑，但是一定要实现Runnable接口。\n接口的本质探讨\n​      接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你是好人，则必须能干掉坏人;如果你是坏人，则必须欺负好人。\n​      接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。\n​      面向对象的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言(比如C++、Java、C#等)，就是因为设计模式所研究的，实际上就是如何合理的去抽象。\n区别\n​     1. 普通类：具体实现\n​     2. 抽象类：具体实现，规范(抽象方法)\n​     3. 接口：规范!\n","categories":[],"tags":["Java基础"]},{"title":"内部类和枚举类","url":"/2019/10/15/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB/","content":"内部类和枚举类\n\ninstanceof它的作用是测试它左边的对象是否是它右边的类的实例，或者右边的类的子类实例，返回 boolean 的数据类型。\nString a = &quot;啊啊啊&quot;;// instanceof 判断 -&gt; boolean true/falseSystem.out.println(a instanceof String);//true a一定是String类型，因为String没什么子类System.out.println(a instanceof Object);//前面的对像是后面的实例或子类都可以是trueObject obj = new Object();System.out.println(obj instanceof String);  //false\n\n\n\n非静态内部类//外部类public class InnerClassDemo &#123;    private int a = 10;    //一个类中包含的元素：属性 方法 构造器 内部类    public void test()&#123;        System.out.println(a);    &#125;    //内部类    class Info&#123;        private int a = 20;        public int info()&#123;            int a = 30;            return a;   //访问优先级：就近原则 return a = 30            //如果没有30  就返回20            //如果没有30 没有20 返回10        &#125;    &#125;&#125;//Tt是外部类// 一个文件里public类只能有一个，并且public修饰的类名必须和文件名一样//相当于在外部定义了一个类Ttclass Tt&#123;&#125;\n\n\n\n静态内部类//外部类public class InnerClassDemo &#123;    //实例成员，想访问10 要现在外面创建实例，然后实例名.    private int a = 10;    //类成员   不用创建实例，直接 类名.    private static int b = 12;    //一个类中包含的元素：属性 方法 构造器 内部类    public void test()&#123;        System.out.println(a);    &#125;    //内部类    class Info&#123;        private int a = 20;        public int info()&#123;            int a = 30;            return a;   //访问优先级：就近原则 return a = 30            //如果没有30  就返回20            //如果没有30 没有20 返回10        &#125;    &#125;    //静态内部类    static class InfoStatic&#123;        int c = 10;        static int d = 20;        void demo()&#123;            //System.out.println(a);  访问不了，因为static先加载，非静态还没加载            System.out.println(b);        &#125;    &#125;&#125;//Tt是外部类// 一个文件里public类只能有一个，并且public修饰的类名必须和文件名一样//相当于在外部定义了一个类Ttclass Tt&#123;&#125;\n\n\n\n非静态内部类与静态内部类的实例化public static void main(String[] args) &#123;        //非静态内部类 实例化：用外部类的实例 去实例化内部类 。再用内部类的实例去调用内部类的方法        InnerClassDemo incerClassDemo = new InnerClassDemo();        InnerClassDemo.Info info = incerClassDemo.new Info();        info.info();        //静态内部类 实例化： 用外部类的类名 直接实例化内部类 。 再用内部类的实例去调用内部类的方法        InnerClassDemo.InfoStatic infoStatic = new InnerClassDemo.InfoStatic();        infoStatic.demo();            &#125;\n\n\n\n匿名内部类匿名内部类适合创建那种只需要一次使用的类，定义匿名内部类的语法格式如下：\nnew 父类构造器（抽象类/接口）\n{\n​      //匿名内部类的 类体部分\n}\n匿名内部类不能是抽象类，匿名内部类不能定义构造器\n抽象类：\npublic class AnonymousMain &#123;    public static void main(String[] args) &#123;    &#125;    public static void testBase()&#123;        //匿名内部类，适用于只使用一次的类        //隐含的含义是：抽象类没有实例，new BaseAnonymous        //会创建一个匿名的内部类，这个内部类继承BaseAnonymous        // ba 指向这个匿名内部类的实例        //方法内部的局部匿名内部类        BaseAnonymous ba = new BaseAnonymous()&#123;            @Override            public void anonymous() &#123;                setName(&quot;张三&quot;);                System.out.println(&quot;anonymous&quot;);            &#125;        &#125;;        ba.anonymous();        System.out.println(ba.getName());    &#125;&#125;\n\n\n\npublic abstract class BaseAnonymous &#123;    private String name;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public abstract void anonymous();&#125;\n\n\n接口是用来实现的\n\n抽象类是用来继承的\n\n\n接口：\n匿名内部类不能是抽象类，也不能定义构造器\n局部内部类如果把一个内部类放在方法里定义，这就是局部内部类，仅仅在这个方法里有效。\n局部内部类不能在外部类以外的地方使用，那么局部内部类也不能使用访部控制符和static修饰\npublic static void test()&#123;      class Inner&#123;                &#125;      Inner inner = new Inner();  &#125;\n\n\n\n枚举类J2SE1.5新增了一个enum关键字，用以定义枚举类。正如前面看到，枚举类是一种特殊的类，它一样可以有自己的方法和属性，可以实现一个或者多个接口，也可以定义自己的构造器。\n当我们要定义一组常量的时候，我们去使用枚举。\n枚举类也是一种类，只是它是一种比较特殊的类，因此它一样可以使用属性和方法\n枚举类可以实现一个或多个接口，使用enum定义的枚举类默认继承了java.lang.Enum类，而不是继承Object类(间接继承)。其中java.lang.Enum类实现了java.lang.Serializable和java.lang.Comparable两个接口。\n枚举类的构造器只能使用private访问控制符，如果省略了其构造器的访问控制符，则默认使用private修饰；如果强制指定访问控制符，则只能指定private修饰符。\n枚举类的所有实例必须在枚举类中显式列出，否则这个枚举类将永远都不能产生实例。列出这些实例时系统会自动添加public static final修饰，无需程序员显式添加。\npublic enum Animal &#123;    PIG,DOG,MONKEY;    public int age;    private Animal()&#123;            &#125;&#125;\n\n所有枚举类都提供了一个values方法，该方法可以很方便地遍历所有的枚举值。 \npublic static void main(String[] args) &#123;       Animal[] animals = Animal.values();       for (Animal anim:animals) &#123;           System.out.println(anim);           System.out.println(anim.age);       &#125;   &#125;\n\n枚举类通常应该设计成不可变类，也就说它的属性值不应该允许改变，这样会更安全，而且代码更加简洁。为此，我们应该将枚举类的属性都使用private final修饰。\n一旦为枚举类显式定义了带参数的构造器，则列出枚举值时也必须对应地传入参数。  \npublic enum Animal &#123;    PIG(10),DOG(20),MONKEY(30);    private final int age; // 推荐    private Animal(int age)&#123;      this.age = age;    &#125;&#125;\n\n枚举类也可以实现一个或多个接口。与普通类实现一个或多个接口完全一样，枚举类实现一个或多个接口时，也需要实现该接口所包含的方法。 \n如果需要每个枚举值在调用同一个方法时呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法，每个枚举值提供不同的实现方式，从而让不同枚举值调用同一个方法时具有不同的行为方式\npublic interface EnumInterface &#123;    void play();&#125;\n\npublic enum Animal implements EnumInterface&#123;    PIG(10)&#123;        @Override        public void play() &#123;            System.out.println(&quot;拱白菜&quot;);        &#125;    &#125;,DOG(20)&#123;        @Override        public void play() &#123;            System.out.println(&quot;啃骨头&quot;);        &#125;    &#125;,MONKEY(30);    private final int age;    private Animal(int age)&#123;      this.age = age;    &#125;    @Override    public void play() &#123;        System.out.println(&quot;耍&quot;);    &#125;&#125;\n\n可以在枚举类里定义一个抽象方法，然后把这个抽象方法交给各枚举值去实现即可。\n包含抽象方法，理解为抽象枚举类，abstract是不需要写的\n枚举类的实例都要实现内部所定义的抽象方法，每个实例理解为匿名内部类的实例\n这个实例可以选择重写枚举类的所有方法，但至少要重写所有的抽象方法\nPIG(10)&#123;       @Override       public void play() &#123;           System.out.println(&quot;拱白菜&quot;);       &#125;       // 类中包含抽象方法，要为每个实例提供相应的实现       @Override       public void yelling() &#123;                  &#125;   &#125;\n\n// 枚举类内部定义    public abstract void yelling(); \n\n\n\n\n\nObject类Object类是所有类、数组、枚举类的父类，也就是说，Java允许把所有任何类型的对象赋给Object类型的变量。当定义一个类时没有使用extends关键字为它显式指定父类，则该类默认继承Object父类。\n打印对象和toString方法：toString方法是系统将会输出该对象的“自我描述”信息，用以告诉外界对象具有的状态信息。Object 类提供的toString方法总是返回该对象实现类的类名 + @ +hashCode值。\n==和equals比较运算符：==要求两个引用变量指向同一个对象才会返回true。equals方法则允许用户提供自定义的相等规则。\nObject类提供的equals方法判断两个对象相等的标准与==完全相同。因此开发者通常需要重写equals方法。\n","categories":[],"tags":["Java基础"]},{"title":"Java内存分析","url":"/2019/10/15/Java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/","content":"JVM虚拟机的内存可以分为三个部分：\n栈（stack）\n堆（heap）\n方法区（method area）（其实也在堆里，只不过比较特殊）\n\n\n\n1. 栈特点：\n\n栈描述的时方法执行的内存模型。每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等）\nJVM为每个线程创建一个栈，用于存放该线程执行方法的信息（实参，局部变量等）\n栈属于线程私有，不能实现线程间的共享！\n栈的存储特性时：先进先出 后进后出\n栈是由系统自动分配，速度快！栈是一个连续的内存空间！\n\n2. 堆特点：\n\n堆用于储存创建好的对象和数组（数组也是对象）\nJVM只有一个堆，被所有线程共享\n堆是一个不连续的内存空间，分配灵活，速度慢！\n\n3.方法区（也叫静态区）特点：\n\nJVM只有一个方法区，被所有线程共享！\n方法区实际也是堆，只是用于存储类、常量相关的信息\n用来存放程序中永远是不变或者唯一的内容（类的信息、静态变量、字符串常量等）\n\neg：\n//Student类//public class Student&#123;\tString brand;\tString.id;\tString name;\t\tvoid play()&#123;\t  System.out.println(&quot;玩玩玩&quot;);\t&#125;\tvoid study()&#123;\t  System.out.println(&quot;学习&quot;+comp.brand);\t&#125;\t\tComputer comp;\tpublic static void main(String[] args)&#123;\t\t\t\t\tStudent stu = new Student();\t\tstu.id = 1001;\t\tstu.name = &quot;卢本伟&quot;;\t\tstu.age = 18;\t\t\t\tComputer c1 = new Computer();\t\tc1.brand = &quot;小米&quot;;\t\t\t\tstu.comp = c1;\t\tstu.play();\t\tstu.study();\t&#125;&#125;class Computer&#123; \tString brand;&#125;\n\n执行步骤：\n\njavac Student.java    java Student    虚拟机执行类\n\n执行Student类 把代码加载到方法区空间中去\n\n\n执行程序的入口 main 方法，在栈中创建main方法的栈帧\n\n\n执行构造方法，在栈中创建构造方法栈帧\n\n\n在堆中创建出对象 构造器销毁\n\n\nstu.id = 1001;  地址给stu，然后把对象的i变成1001\n\n\nstu.name = “卢本伟”； 把字符串常量的地址给name 然后变成 卢本伟\n\n\n之后age类似 就不画了\n\n之后构造器创建c1 ，过程和之前一样\n\n把“小米”给他\n\n\n把c1的值给comp ，此时comp: 13db9780，所以也指向了从c1的地址\n\n\n\n","categories":[],"tags":["Java基础"]},{"title":"初识HTTP","url":"/2019/08/23/%E5%88%9D%E8%AF%86HTTP/","content":"Http\n\n\n定义：超文本传输协议\n作用：规范了浏览器和服务器数据交互的格式，没有也可以，但是会阻碍互联网的发展\n特点：简单快捷灵活 无连接无状态 1.1版本支持可持续连接\n\n交互流程\n客户端和服务端建立简介\n发送请求：客户端发送请求到服务器端（HTTP协议）\n接收响应：服务端接收到请求后，进行处理，然后将处理结果相应客户端（HTTP协议）\n关闭客户端和服务器端的连接（HTTP1.1后不会立即关闭）\n\nHTTP协议请求格式\n请求头：请求方式（get/post…）请求的地址和HTTP协议版本\n请求行：消息包头，一般用来说明客户端要使用的一切附加信息\n空行：位于请求行和请求数据之间，空行是必须的 \n请求数据：非必须\n\nget和post请求方式的区别\nget\n请求数据会以？的形式隔开拼接在请求头中，不安全，没有请求实体部分。\nHTTP协议虽然没有规定请求数据的大小，但是浏览器对URL的长度是有限制的，所以get请求不能携带大量的数据。\n如果传输数据小，对安全没有要求，用get，效率高。\n\npost\n请求数据在请求实体中进行发送，在URL中看不到具体的请求数据，安全。适合数据量大的数据发送。\n\n\nHTTP协议之响应响应格式的结构：\n响应行：HTTP版本，状态码，状态信息\n响应头：消息报头，客户端使用的附加信息\n空行：响应头和响应实体之间的，必须的\n响应实体：正文，服务器返回给浏览器的信息\n\nHTTP常见响应状态码HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型\n\n**信息，服务器收到请求，需要请求者继续执行操作\n\n**成功，操作被成功接收并处理\n\n**重定向，需要进一步的操作以完成请求\n\n**客户端错误，请求包含语法错误或无法完成请求\n\n**服务器错误，服务器在处理请求的过程中发生了错误\n\n\n常见的HTTP状态码\n\n200 – 请求成功\n301 – 资源(网页等)被永久转移到其它URL\n404 – 请求的资源(网页等)不存在\n500 – 内部服务器错误\n\n","categories":[],"tags":["网络"]},{"title":"HEXO博客的搭建","url":"/2019/08/10/HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","content":"Hexo\n\n搭建\n安装git\n\n安装node.js\n\n创建blog文件夹，git bash打开\n\n安装hexo\n\nnpm install -g hexo-cli\n\n查看版本\nhexo -v\n\n初始化hexo\nhexo init myblog   //这个myblog起什么名字都行\n\ncd myblog\n\nnpm install\n\nhexo g\n\nhexo s    //打开hexo的服务\n\n\n在浏览器输入localhost:4000就可以看到你生成的博客了。\n\n部署到github\n在github建一个仓库  用户名.github.io\n\n安装插件 \ncnpm install --save hexo-deployer-git\n\n修改config文件\n\n\ndeploy:     type: git     repo:https://github.com/YourgithubName/YourgithubName.github.io.git     branch: master \n\n\n部署到远端 \nhexo d\n\n\n\n\n写博客\n hexo n &quot;标题&quot;\n然后就markdown写\n&lt;!--more--&gt;    标签下面的内容不显示\n\n插入图片：\n\n设置站点配置_config.yml:将post_asset_folder: false改为post_asset_folder: true\n安装插件npm install https://github.com/CodeFalling/hexo-asset-image -- save\n运行hexo n “XXXXXX”,生成XXXXX.md博文时就会在/source/_posts目录下生成XXXXXX的文件夹，将你想在XXXXX博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意。\n添加图片:在想添加的位置写入![你想输入的替代文字](/xxxx/图片名.jpg)（斜杠都不能少）\n\n\n发表\n在bolg目录\n\nhexo clean   //清理一下\nhexo g   //生成\nhexo s\n\n\n修改主题\ngithub.com/litten/hexo-theme-yilia\n\n下载主题\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n\n在config文件修改\n\n\n​        theme 后面改成你的主题名\n\nhexo clean  清理\nhexo g  生成\nhexo s  发布\nlocalhost4000端口改了\n\nhexo d   推到远端 github的就改了\n\n\n自定义配置打开根目录config（不要用记事本，用vscode）\n\n\n\n参数\n含义\n\n\n\ntitle\n网站的标题\n\n\nsubtitle\n网站的副标题\n\n\ndescription\n网站的描述\n\n\nauthor\n你的名字\n\n\nlanguage\n网站使用的语言(中文：zh-CN)\n\n\ntimezone\n时区，默认电脑时区\n\n\ntheme\n主题\n\n\n\n中文乱码：根目录config文件\nlanguage: zh-Hans或者language: zh-CN\n（取决于你的主题theme目录下的language目录下有zh-Hans.yml还是zh-CN.yml）\n\n\n\n头像/图标\n\n存放位置：\n头像/图标图片的存放位置是/themes/yilia/source/下任意位置，可以自己新建一个文件夹存放，我存放在assets文件夹下。\n\n配置设置：\n配置文件为/themes/yilia/_config.yml。设置头像为配置文件中avatar一项，设置图标为配置文件中favicon一项，设置路径的根目录为/themes/yilia/source/。例如，我的头像存放的地址是/themes/yilia/source/assets/me.png，设置则为avatar: /assets/me.png。（图标同理）\n\n\n\n\n","categories":[],"tags":["HEXO"]},{"title":"IO流","url":"/2019/08/09/IO%E6%B5%81/","content":"I/O 流 \n\n字节流读取文件步骤\n\n在当前程序与指定的文件之间建立流通道\n读写文件内容\n关闭流通道\n\nInputStream    读网络中，发送请求到服务器获取数据，服务器返回的数据，一般要通过（输入）流来获取\n文件输入流FileInputStream    \n\nint read() 依次读一个字节\nint read(byte[] b)\nint read(byte[] b,offset,length)\n\n可以一个字节一个字节读\npublic static void main(String[] args) throws IOException &#123;       // （1） 在当前程序与指定的文件之间建立流通道       // 读取d:/abc.txt文件的内容，通过构造方法指定要访问的文件，如果文件不存在则会抛出异常       FileInputStream fis = new FileInputStream(&quot;c:/DCIM/1.txt&quot;);       //（2）读取文件内容       // read（） 方法会从文件中读取一个字节，并把读到的字节返回，读到文件末尾返回-1       int cc = fis.read();       while(cc != -1)&#123;           System.out.print((char) cc);           cc = fis.read();       &#125;       // （3） 关闭流通道       fis.close();   &#125;\n\n\n\n也可以用字节数组读\npublic static void main(String[] args) throws IOException &#123;     FileInputStream fis = new FileInputStream(&quot;c:/DCIM/1.txt&quot;);     byte[] bytes = new byte[1024];     int cc = fis.read(bytes);     while(cc&gt;0)&#123;         System.out.print(new String(bytes,0,cc));         cc = fis.read(bytes);     &#125;     fis.close();   &#125;\n\n把创建流 写在try（）里的资源块里，就自动释放，不用手动关闭流了,(是在jdk7之后，jdk6的话 就得在finally中关闭流)\nprivate static void m1()&#123;       try (       //try资源块，自动释放,就不用手动关闭流了(是在jdk7之后，jdk6的话 就得在finally中关闭流)                   FileInputStream fis = new FileInputStream(&quot;c:/DCIM/1.txt&quot;);               )&#123;           byte[] bytes = new byte[4];           int ss = fis.read(bytes);           while(ss != -1)&#123;               System.out.println(new String(bytes,0,ss));               ss = fis.read(bytes);           &#125;       &#125; catch (Exception e)&#123;           e.printStackTrace();       &#125;   &#125;\n\n\n\nOutputStream    写文件输出流FileOutputStream\n\nwrite()\nwrite(byte[] b,offset, lengtj)\n\n/** * FileOutputStream * 以字节为单位，把数据保存到文件中 */public class Test05 &#123;    public static void main(String[] args) throws IOException &#123;        // （1）建立流通道，通过构造方法的参数指定要访问的文件        // 如果访问文件不存在，系统会自动创建一个文件        //如果文件存在，会覆盖原来的文件内容        //后面加个true，会以追加的方式存文件（就是在文件的后面加上）        FileOutputStream fos = new FileOutputStream(&quot;c:/DCIM/2.txt&quot;,true);        //（2）写文件        //2.1 一次写一个字符        fos.write(65);  //把265对应的字符A保存到文件中        fos.write(66);        fos.write(67);        //换行 在windows系统中，换行需要使用 \\r\\n 两个字符        fos.write(&#x27;\\r&#x27;);    //回车 13        fos.write(&#x27;\\n&#x27;);    // 换行 10        //2.2一次写一个字节数组        byte[] bytes = &quot;sfasdaf&quot;.getBytes();        fos.write(bytes);        //换行        fos.write(13);        fos.write(10);        //2.3把字节数组的部分字节保存到文件中        fos.write(bytes,0,2);        //（3）关闭流        fos.close();    &#125;&#125;\n\n\n\n字节流文件复制public class Test01 &#123;    public static void main(String[] args) throws IOException &#123;        String src = &quot;c:/DCIM/1.txt&quot;;        String deString = &quot;c:/DCIM/2.txt&quot;;        copyFile(src,deString);    &#125;    public static void copyFile(String srcFilename,String destFilename)&#123;        //使用try-catch  然后创建流写try后面的()里，这样不需要关闭流，会自动关闭        try(FileInputStream fis = new FileInputStream(srcFilename);            FileOutputStream fos = new FileOutputStream(destFilename);)&#123;            byte[] byteArr = new byte[1024];        //一般是1024的偶数倍            int len = fis.read(byteArr);            while(len!= -1 )&#123;                //如果len不是-1 把cc保存到目标文件中                // 把读到的len 保存到输出流中                fos.write(byteArr,0,len);                len = fis.read(byteArr);            &#125;        &#125; catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n\n\n\n字符流以Reader     Writer为结尾的类，都是字符流    涉及到文本 用字符流    汉字和英文读取时没有差异，就是一个字符\n以Stream为结尾的类，都是字节流    多媒体：音频 视频 图片 只能用字节流\n​    网络交互——&gt;字节流 ——&gt;转换成字符流操作，方便\n字符流文件复制/** * 文件字符流复制 */public class FileCharCopy &#123;    public static void main(String[] args) &#123;        // 这个目录下的1.txt  复制到 2.txt        fileCopy(&quot;c:/DCIM/1.txt&quot;,&quot;c:/DCIM/2.txt&quot;);    &#125;    public static void fileCopy(String fileRead,String fileWrite)&#123;        try(                //使用try-catch  然后创建流写try后面的()里，这样不需要关闭流，会自动关闭                FileReader fr = new FileReader(fileRead);                FileWriter fw = new FileWriter(fileWrite);                )&#123;            char[] chrArr = new char[1024];            int len = fr.read(chrArr);            while(len != -1)&#123;                //如果len不是-1 把len保存到目标文件中                // 把读到的len 保存到输出流中                fw.write(chrArr,0,len);                len = fr.read(chrArr);            &#125;        &#125; catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n\n转换流FileReader/FileWriter 只能读写与当前环境编码兼容的文件\n如果文本文件与当前环境编码不兼容，使用InputStreamReader/OutputStreamWriter转换流读写\n转换流采用了适配器设计模式\n字节流 -&gt; 字符流 -&gt; 字符流相关的方法进行操作\n字节流 FileInputStream -&gt; 字符流 BufferedReader\npublic class Test06 &#123;    public static void main(String[] args) throws IOException &#123;            m1();   // 使用InputStreamReader读取文本内容        m2();   //  使用OutputStreamWriter 保存数据    &#125;    //当操作的文件编码与当前环境编码不兼容，使用InputStreamReader读取    public static void m1() throws IOException &#123;        // 在当前程序与指定的文件之间建立流通道        // InputStream 是父类，FileInputStream是子类，多态的应用        //因为要用InputStreamReader 把字节流转成字符流，InputStreamReader 里面传的参数是 InputStream ，而不是FileInputStream ，体现了多态的优点，减少代码冗余        InputStream in = new FileInputStream(&quot;c:/DCIM/1.txt&quot;);        // 使用UTF-8 编码 ，把in字节流中的数据转成字符流        InputStreamReader isr = new InputStreamReader(in,&quot;UTF-8&quot;);        int len = isr.read();        while(len != -1)&#123;            System.out.print((char)len);            len=isr.read();        &#125;        isr.close();    &#125;    public static void m2() throws IOException &#123;        OutputStream os = new FileOutputStream(&quot;c:/DCIM/3.txt&quot;);        OutputStreamWriter osw = new OutputStreamWriter(os,&quot;UTF-8&quot;);        osw.write(&quot;\\r\\n&quot;);        osw.write(&quot;当前的内容是使用转换流保存到文件中&quot;);        osw.close();    &#125;&#125;\n\n\n\n缓冲流\n/** * 字符缓冲流 * BufferedReader/BufferedWriter * 也成为处理流/包装流 * */public class HuanChongLiu &#123;    public static void main(String[] args) throws IOException &#123;       m1();        //使用BufferedReader 读取文本文件内容        m2();       //使用BufferedWriter 保存文本到文件        m3();   //从键盘上输入文本，把这些文本保存到文件中    &#125;    private static void m1() throws IOException &#123;        Reader in = new FileReader(&quot;c:/DCIM/1.txt&quot;);        BufferedReader br = new BufferedReader(in);        // 从缓冲字符流中读取一行，读到文件末尾返回null        String line = br.readLine();        while(line!=null)&#123;            System.out.println(line);            line = br.readLine();        &#125;        //  把缓冲流关闭后，被包装的流也会关闭        br.close();    &#125;    private static void m2() throws IOException &#123;        Writer out = new FileWriter(&quot;c:/DCIM/3.txt&quot;,true);        BufferedWriter bw = new BufferedWriter(out);        out.write(&quot;因为爱情，不会轻易悲伤&quot;);        bw.flush();    //清空缓冲区，把数据保存到文件中        //或者 写 bw.close();  因为close方法也提供flush    &#125;    private static void m3() throws IOException &#123;        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;c:/DCIM/3.txt&quot;));        // 使用BufferedReader 对键盘输入流缓冲        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        //System.in 是字节流，InputStreamReader把字节流转换成字符流        String line = br.readLine();        while(line.length()&gt;0)&#123;     //键盘输入的长度大于0，表示你确实输入了            bw.write(line);            bw.newLine();            line = br.readLine();        &#125;        br.close();        bw.close();    &#125;&#125;\n\n\n\n\n\n\n\n对象流对象序列化：把对象转换为01二进制序列就是对象序列化    \n对象反序列化：把一组01二进制序列转换为对象    \n注意：对象序列化/反序列化 前提是 对象的类 要实现 Serializable接口，该接口是一个标志性接口，没有任何方法\n目标：将对象保存到磁盘中，或允许在网络中直接传输对象\nSerializable 序列化，是一个接口，接口无内容，如果一个类实现了这个接口，那么就表示这个类的对象可以序列化\n网络中传输对象或者将对象保存到本地磁盘都需要序列化\n序列化与反序列化\n\n序列化    写的时候\n反序列化  读的时候，反序列化成对象\n\nObjectOutputStream类 可以把对象序列化，把序列化后二进制保存到文件中（序列化）\nObjectInputStream类 可以从文件读取01序列，把这组01序列转化为对象（反序列化）\n一般情况下，类实现了Serializable接口后，手动的添加一个序列化版本号字段\nprivate static final long serialVersionUID = -6849794470767710L;\n\n\n\n序列化\npublic class XuLieHua &#123;    public static void main(String[] args) throws IOException &#123;        Person p1 = new Person(&quot;yongge&quot;,36);        // 对象序列化,把p1对象保存到c:/DCIM/3.txt文件中        OutputStream out = new FileOutputStream(&quot;c:/DCIM/3.txt&quot;);        ObjectOutputStream os = new ObjectOutputStream(out);        os.writeObject(p1);        os.close();    &#125;&#125;\n\n反序列化\n/** * 对象反序列化 *  简单的理解为把对象从文件中读取出来 */public class FanXuliehua &#123;    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        InputStream in = new FileInputStream(&quot;c:/DCIM/3.txt&quot;);        ObjectInputStream ois = new ObjectInputStream(in);        //从文件中读取一个对象，obj是Object类型的，引用的是person对象        Object obj = ois.readObject();        System.out.println(obj);        ois.close();        /**         *  场景描述：         *      把对象序列化到文件后，又在Person类中添加了一个字段（String sex），再进行反序列化时产生以下异常         *      Exception in thread &quot;main&quot; java.io.InvalidClassException: day10.io.Person; local class incompatible:         *      stream classdesc serialVersionUID = -6042614482052494089,         *      local class serialVersionUID = -3602205828298551354         *         *  分析：         *      Person类实现了Serializable接口后，系统会给类自动添加一个serialVersionUID序列化版本号字段         *      当再Person类添加/删除了一个字段，重新编译，serialVersionUID字段会生成一个新的值         *         *  解决：         *      保证对象序列化时与反序列化时serialVersionUID字段的值要相同         *      可以手动的添加一个serialVersionUID字段         */    &#125;&#125;public class Person implements Serializable &#123;    /**     *  Person类的对象序列化/反序列化的前提是Person类实现Serializable接口     *  该接口没有任何方法     *  一般情况下，类实现了Serializable接口后，会手动添加一个serialVersionUID序列化版本号字段     *     *     */    String name;    int age;    String sex;    //手动添加一个序列化版本号字段    // 点开String类里 把这段话粘过来，然后把后面的字段自己随便删点改点    // serialVersionUID 是个常量 没有所有字母都大写，特殊    private static final long serialVersionUID = -6849794470767710L;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Person() &#123;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n\n打印流PrintStream    字节打印流/** * PrintStream * 打印字节流 */public class PrintStreamDemo &#123;    public static void main(String[] args) throws FileNotFoundException &#123;        // 1）        OutputStream out = new FileOutputStream(&quot;c:/DCIM/3.txt&quot;);        PrintStream pStream = new PrintStream(out);        pStream.print(&quot;hello&quot;);        pStream.println(&quot; world&quot;);        // 2） System类的out成员就是PrintStream类型的打印流        //  System.out 默认系统的标准输出设备是显示器        System.out.println(&quot;默认在显示器上打印信息&quot;);        //可以修改Systen.out的打印方向        System.out.println(pStream);        System.out.println(&quot;这一行信息就不是在屏幕上显示，而是打印到pStream这个流中，即3.txt文件&quot;);        //3）经常把异常信息保存到日志文件中        try&#123;            FileInputStream fis = new FileInputStream(&quot;f:/asfas.txt&quot;);        &#125; catch (Exception e)&#123;            //在开发时，一般调用e.printStackTrace() 把异常信息打印到屏幕上方便程序员调试            //在部署后，会把异常信息打印到日志文件中            e.printStackTrace(pStream);        &#125;    &#125;&#125;\n\n\n\nPrintWriter    字符打印流public class PrintDemo &#123;    public static void main(String[] args) throws IOException &#123;        PrintWriter pw = new PrintWriter(new FileWriter(&quot;c:/DCIM/3.txt&quot;));        pw.print(&quot;这是字符打印流&quot;);        try&#123;            FileInputStream fis = new FileInputStream(&quot;f:/3werwrf.txt&quot;);        &#125; catch(Exception e) &#123;            e.printStackTrace();        &#125;        pw.close();    &#125;&#125;\n\n\n\nFile类读取文件内容使用I/O流，操作文件/文件夹使用File类，如创建/遍历/删除文件夹，查看文件的相关属性等操作\n/** * 创建File对象 */public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        File f1 = new File(&quot;c:/DCIM/JAVA123&quot;);        f1.mkdir(); // 创建文件夹        File f2 = new File(&quot;c:/DCIM/JAVA123/sb1&quot;);        f2.mkdir();        File f3 = new File(&quot;c:/DCIM/JAVA123&quot;,&quot;sb2&quot;);        f3.createNewFile();        File f4 = new File(f2,&quot;sb3&quot;);        f4.createNewFile();    &#125;&#125;\n\n\n\n/** * 查看文件属性 */public class FileShuxing &#123;    public static void main(String[] args) &#123;        //File f1 = new File(&quot;c:/DCIM/2.txt&quot;);        File f1 = new File(&quot;2.txt&quot;);    //相对路径，要项目目录下的文件        System.out.println(f1.getAbsolutePath());   //返回绝对路径（从根目录开始的路径）        System.out.println(f1.getParent());   //  返回上一级文件夹        System.out.println(f1.getPath());   //  返回路径        System.out.println(f1.getName());      // 对象名        System.out.println(f1.length());    //文件大小        System.out.println(f1.exists());    //是否存在        System.out.println(f1.isFile());    //是否为文件        System.out.println(f1.isAbsolute());    //是否绝对路径        System.out.println(f1.lastModified());  // 最后一次修改的时间    &#125;&#125;class WenjianJia&#123;    public static void main(String[] args) &#123;        listSub1(&quot;c:/DCIM&quot;);        listSub2(&quot;c:/DCIM&quot;);    &#125;    //显示指定文件夹的内容    public static void listSub1(String dirname)&#123;            File dir = new File(dirname);            String[] subs = dir.list();        for (String s:subs             ) &#123;            System.out.println(s);        &#125;    &#125;    //显示绝对路径    public static void listSub2(String dirname)&#123;        File dir = new File(dirname);        File[] listFiles = dir.listFiles();        for (File file:listFiles             ) &#123;            System.out.println(file.getAbsolutePath());            //如果file对象时文件夹，显示该子文件夹的内容            if(file.isDirectory())&#123;                listSub2(file.getAbsolutePath());       //递归调用            &#125;        &#125;    &#125;&#125;\n\n\n\nRandomAccessFile是Java输入/输出体系中功能最丰富的文件内容访问类\n支持随机访问的方式，程序可以直接跳转到文件的任意地方来读写数据\nRandomAccessFile体重了一个访问指针，而我们可以自由定位这个指针，程序若想已存在文件后追加内容，则应该使用RandowAccessFile\n节点流/处理流如果直接从设备（数据源）上读写数据就是节点流，处理流是对节点流的包装\n","categories":[],"tags":["Java基础"]},{"title":"冒泡排序的一些理解","url":"/2019/08/09/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","content":" \n\n冒泡排序从小到大比较 ，两两比较，如果前面的大于后面的，就交换他们的位置，经过多轮比较，实现从小到大排序\n主要思路就是交换两个元素，需要引入第三个变量\n比如有两个杯子，第一个杯子里是水，第二个杯子里是酒，想把酒放第一个杯子里，水放第二个杯子里，要再拿一个空杯子\n\n把第一个杯子里的水放空杯子里\n\n把第二个杯子里的酒放第一个杯子里\n\n把后拿的杯子里的水再放第二个杯子里\n\n\n48 95 35 86 40 -&gt; 两两比较 大的往后移48 35 86 40 95 -&gt; 95排到最后 最大35 48 40 86 95 -&gt; 95不动 比较前面的35 40 48 86 95 -&gt; 95 86不动 比较前面的35 40 48 86 95 -&gt; 95 86 48不动 比较35和40\n\nstatic int[] iArr = &#123;48,95,35,86,40&#125;;    public static void main(String[] args) &#123;  // 如果感觉思路不清晰 可以再这打段点 然后debug一下   \t\t for (int i = 0 ; i &lt; iArr.length-1; i ++) &#123;            for (int j = 0; j &lt; iArr.length -  i - 1; j++) &#123;                if(iArr[j] &gt; iArr[j+1])&#123;                    //  交换两个元素的位置，需要引入第三个变量 也就是空杯子                    int temp = iArr[j];                    iArr[j] = iArr[j+1];                    iArr[j+1] = temp;                &#125;            &#125;        &#125;\t\t\t\t//\tforeach 循环遍历数组        for (int x:iArr) &#123;            System.out.println(x);        &#125;    &#125;\n\n冒泡排序优化版——快速排序\n","categories":[],"tags":["算法"]},{"title":"Java环境配置","url":"/2019/08/09/Java%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"Java环境配置\n\njdk版本 1.8\njdk： Java Development Kit 是 Java 语言的软件开发工具包\njre： Java Runtime Environment  指Java运行环境\n\n安装注意事项\n安装路径不要有中文和空格\nJRE不要安在JDK目录下面\n\n常用快捷键\nwin+d 回到桌面\nwin+e 打开文件资源管理器\nwin+r 打开运行窗口\n\n环境变量\n我的电脑 -&gt; 右键 -&gt; 属性 -&gt; 高级系统设置 -&gt; 高级 -&gt; 环境变量 \n系统变量 -&gt; 新建 -&gt; 变量名: JAVA_HOME 变量值: Jdk安装路径\n系统变量 -&gt; Path -&gt;编辑 -&gt; 新建 %JAVA_HOME%\\bin -&gt; 新建  %JAVA_HOME%\\jre\\bin\n\n测试\nwin+r \n输入cmd \n输入java -version 或 java 或 javac\n\n注意： 每修改一次环境变量，需要重新打开一个窗口进行测试##IDE\nIDEA安装包及详细安装步骤：参考U盘或者网盘JVM java虚拟机java文件 -&gt; 编译生成class文件（字节码文件，二进制文件）-&gt; 加载到JVM中运行\nJVM\n\nWindows\nMac\nLinux\n\n每个操作系统安装JVM后，都可以加载class文件执行，Java具有跨平台特性，一次编译，多处运行\nGC垃圾回收， java垃圾回收机制：自动回收Student stu = new Student();  创建一个对象，需要分配空间stu=null; 回收的前提 这样之后会根据JVM内部的垃圾回收算法，当达到一定条件开始回收这些资源\n\n\n\n面向对象之后，不用的对象，清空 设置为null\nIDEA开发\n前端 ：webstorm \npython：pycharme\njava：Idea\n\nsrc：源代码目录\n在学习多线程之前，目前我们的代码都是单线程的，代码运行在主线程（main thread）中，执行顺序从上向\n快捷键\npsvm\npublic static void main(String[] args) &#123;       &#125;   //main方法是程序执行的入口\nsout\n\n\nSystem.out.println();\n\n\nctrl + shift + /\n\n选中代码注释掉\n不选中代码的话是直接生成多行注释\n\n\n/** + 回车\n/** * 直接生成文档注释 */\nctrl + alt + L \n代码格式化\n\nctrl+shift+alt+u\n\nctrl+e\n最近的工作目录\n\n\n改编码\nGBK 国际码\nUTF-8 万国码 国际通用编码\n\n编码不一致会导致乱码\nFile -&gt; Settings -&gt; 输入Encod -&gt; File Encodings -&gt; 都改成UTF-8\n注释单行 //多行 /* */  快捷键：ctrl+shift+/##包package\n\nJava项目 -&gt; java文件成千上万个 -&gt; 想找某一个文件很困难 -&gt; 分包管理\n\n后期\n\nservice \ndao \npojo/bean \ncontraller\n\n每个包中放跟这个包名关系密切的相关文件命名: 域名倒置\nbaidu.com -&gt; com.baidu\n命名规范公司.部门.项目名.项目模块 \n创建src -&gt; 右键 -&gt; new -&gt; package -&gt; com.train.day.01\n","categories":[],"tags":["Java基础"]},{"title":"my first blog","url":"/2019/08/08/my-first-blog/","content":"我的第一篇博客终于配置成功！\n","categories":[],"tags":["life"]}]